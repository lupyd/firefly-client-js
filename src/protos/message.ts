// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.1
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "firefly";

export interface UserMessage {
  id: bigint;
  to: string;
  from: string;
  text: Uint8Array;
  conversationId: bigint;
  type: number;
}

export interface Group {
  id: bigint;
  name: string;
  description: string;
  pfp: boolean;
  state: Uint8Array;
}

export interface Groups {
  groups: Group[];
}

export interface UserMessages {
  messages: UserMessage[];
}

export interface GroupInvite {
  groupId: bigint;
  inviter: string;
  invitee: string;
  welcomeMessage: Uint8Array;
  commitId: bigint;
}

export interface GroupInvites {
  invites: GroupInvite[];
}

export interface GroupMessage {
  id: bigint;
  groupId: bigint;
  message: Uint8Array;
}

export interface GroupKeyPackage {
  id: number;
  package: Uint8Array;
}

export interface GroupKeyPackages {
  packages: GroupKeyPackage[];
}

export interface GroupMessages {
  messages: GroupMessage[];
}

export interface ServerMessage {
  userMessage?: UserMessage | undefined;
  groupMessage?: GroupMessage | undefined;
  userMessages?: UserMessages | undefined;
  groupMessages?: GroupMessages | undefined;
}

export interface SubscribeGroup {
  id: bigint;
}

export interface UnSubscribeGroup {
  id: bigint;
}

export interface ClientMessage {
  userMessage?: UserMessage | undefined;
  groupMessage?: GroupMessage | undefined;
  userMessages?: UserMessages | undefined;
  groupMessages?: GroupMessages | undefined;
  bearerToken?: string | undefined;
  subscribeGroup?: SubscribeGroup | undefined;
  unSubscribeGroup?: UnSubscribeGroup | undefined;
}

export interface GroupId {
  id: bigint;
}

export interface AuthToken {
  username: string;
  validUntil: bigint;
  issuer: string;
  credential: Uint8Array;
}

export interface SignedToken {
  kid: string;
  payload: Uint8Array;
  signature: Uint8Array;
}

export interface FireflyClient {
  username: string;
  secret: Uint8Array;
  public: Uint8Array;
  credential: Uint8Array;
}

export interface FireflyGroupExtension {
  name: string;
  roles: FireflyGroupRoles | undefined;
  channels: FireflyGroupChannels | undefined;
  members: FireflyGroupMembers | undefined;
}

export interface FireflyGroupRole {
  id: number;
  name: string;
  permissions: bigint;
}

export interface FireflyGroupRoles {
  roles: FireflyGroupRole[];
}

export interface FireflyGroupMember {
  username: string;
  role: number;
}

export interface FireflyGroupMembers {
  members: FireflyGroupMember[];
}

export interface FireflyGroupChannel {
  id: number;
  name: string;
  type: number;
  roles: FireflyGroupRoles | undefined;
}

export interface FireflyGroupChannels {
  channels: FireflyGroupChannel[];
}

export interface PreKeyBundle {
  registrationId: number;
  deviceId: number;
  preKeyId: number;
  prePublicKey: Uint8Array;
  signedPreKeyId: number;
  signedPrePublicKey: Uint8Array;
  signedPreKeySignature: Uint8Array;
  identityPublicKey: Uint8Array;
  KEMPreKeyId: number;
  KEMPrePublicKey: Uint8Array;
  KEMPreKeySignature: Uint8Array;
}

export interface ConversationStart {
  conversationId: bigint;
  startedBy: string;
  other: string;
  bundle: PreKeyBundle | undefined;
}

export interface PreKeyBundles {
  bundles: PreKeyBundle[];
}

export interface Conversation {
  id: bigint;
  startedBy: string;
  other: string;
}

export interface Conversations {
  conversations: Conversation[];
}

export interface UserMessageInner {
  plainText?: Uint8Array | undefined;
  callMessage?: Uint8Array | undefined;
}

function createBaseUserMessage(): UserMessage {
  return { id: 0n, to: "", from: "", text: new Uint8Array(0), conversationId: 0n, type: 0 };
}

export const UserMessage: MessageFns<UserMessage> = {
  encode(message: UserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    if (message.text.length !== 0) {
      writer.uint32(34).bytes(message.text);
    }
    if (message.conversationId !== 0n) {
      if (BigInt.asUintN(64, message.conversationId) !== message.conversationId) {
        throw new globalThis.Error("value provided for field message.conversationId of type uint64 too large");
      }
      writer.uint32(40).uint64(message.conversationId);
    }
    if (message.type !== 0) {
      writer.uint32(48).uint32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.conversationId = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessage {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
      text: isSet(object.text) ? bytesFromBase64(object.text) : new Uint8Array(0),
      conversationId: isSet(object.conversationId) ? BigInt(object.conversationId) : 0n,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
    };
  },

  toJSON(message: UserMessage): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    if (message.text.length !== 0) {
      obj.text = base64FromBytes(message.text);
    }
    if (message.conversationId !== 0n) {
      obj.conversationId = message.conversationId.toString();
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessage>, I>>(base?: I): UserMessage {
    return UserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessage>, I>>(object: I): UserMessage {
    const message = createBaseUserMessage();
    message.id = object.id ?? 0n;
    message.to = object.to ?? "";
    message.from = object.from ?? "";
    message.text = object.text ?? new Uint8Array(0);
    message.conversationId = object.conversationId ?? 0n;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseGroup(): Group {
  return { id: 0n, name: "", description: "", pfp: false, state: new Uint8Array(0) };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.pfp !== false) {
      writer.uint32(32).bool(message.pfp);
    }
    if (message.state.length !== 0) {
      writer.uint32(42).bytes(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pfp = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pfp: isSet(object.pfp) ? globalThis.Boolean(object.pfp) : false,
      state: isSet(object.state) ? bytesFromBase64(object.state) : new Uint8Array(0),
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pfp !== false) {
      obj.pfp = message.pfp;
    }
    if (message.state.length !== 0) {
      obj.state = base64FromBytes(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Group>, I>>(base?: I): Group {
    return Group.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Group>, I>>(object: I): Group {
    const message = createBaseGroup();
    message.id = object.id ?? 0n;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.pfp = object.pfp ?? false;
    message.state = object.state ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroups(): Groups {
  return { groups: [] };
}

export const Groups: MessageFns<Groups> = {
  encode(message: Groups, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Groups {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroups();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Groups {
    return { groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [] };
  },

  toJSON(message: Groups): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Groups>, I>>(base?: I): Groups {
    return Groups.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Groups>, I>>(object: I): Groups {
    const message = createBaseGroups();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserMessages(): UserMessages {
  return { messages: [] };
}

export const UserMessages: MessageFns<UserMessages> = {
  encode(message: UserMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      UserMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(UserMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => UserMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => UserMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessages>, I>>(base?: I): UserMessages {
    return UserMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessages>, I>>(object: I): UserMessages {
    const message = createBaseUserMessages();
    message.messages = object.messages?.map((e) => UserMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupInvite(): GroupInvite {
  return { groupId: 0n, inviter: "", invitee: "", welcomeMessage: new Uint8Array(0), commitId: 0n };
}

export const GroupInvite: MessageFns<GroupInvite> = {
  encode(message: GroupInvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.groupId);
    }
    if (message.inviter !== "") {
      writer.uint32(18).string(message.inviter);
    }
    if (message.invitee !== "") {
      writer.uint32(26).string(message.invitee);
    }
    if (message.welcomeMessage.length !== 0) {
      writer.uint32(34).bytes(message.welcomeMessage);
    }
    if (message.commitId !== 0n) {
      if (BigInt.asUintN(64, message.commitId) !== message.commitId) {
        throw new globalThis.Error("value provided for field message.commitId of type uint64 too large");
      }
      writer.uint32(40).uint64(message.commitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invitee = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.welcomeMessage = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.commitId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInvite {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      inviter: isSet(object.inviter) ? globalThis.String(object.inviter) : "",
      invitee: isSet(object.invitee) ? globalThis.String(object.invitee) : "",
      welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array(0),
      commitId: isSet(object.commitId) ? BigInt(object.commitId) : 0n,
    };
  },

  toJSON(message: GroupInvite): unknown {
    const obj: any = {};
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.inviter !== "") {
      obj.inviter = message.inviter;
    }
    if (message.invitee !== "") {
      obj.invitee = message.invitee;
    }
    if (message.welcomeMessage.length !== 0) {
      obj.welcomeMessage = base64FromBytes(message.welcomeMessage);
    }
    if (message.commitId !== 0n) {
      obj.commitId = message.commitId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInvite>, I>>(base?: I): GroupInvite {
    return GroupInvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInvite>, I>>(object: I): GroupInvite {
    const message = createBaseGroupInvite();
    message.groupId = object.groupId ?? 0n;
    message.inviter = object.inviter ?? "";
    message.invitee = object.invitee ?? "";
    message.welcomeMessage = object.welcomeMessage ?? new Uint8Array(0);
    message.commitId = object.commitId ?? 0n;
    return message;
  },
};

function createBaseGroupInvites(): GroupInvites {
  return { invites: [] };
}

export const GroupInvites: MessageFns<GroupInvites> = {
  encode(message: GroupInvites, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invites) {
      GroupInvite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInvites {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInvites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invites.push(GroupInvite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInvites {
    return {
      invites: globalThis.Array.isArray(object?.invites) ? object.invites.map((e: any) => GroupInvite.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupInvites): unknown {
    const obj: any = {};
    if (message.invites?.length) {
      obj.invites = message.invites.map((e) => GroupInvite.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInvites>, I>>(base?: I): GroupInvites {
    return GroupInvites.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInvites>, I>>(object: I): GroupInvites {
    const message = createBaseGroupInvites();
    message.invites = object.invites?.map((e) => GroupInvite.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupMessage(): GroupMessage {
  return { id: 0n, groupId: 0n, message: new Uint8Array(0) };
}

export const GroupMessage: MessageFns<GroupMessage> = {
  encode(message: GroupMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.groupId);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMessage {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupMessage): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMessage>, I>>(base?: I): GroupMessage {
    return GroupMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMessage>, I>>(object: I): GroupMessage {
    const message = createBaseGroupMessage();
    message.id = object.id ?? 0n;
    message.groupId = object.groupId ?? 0n;
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroupKeyPackage(): GroupKeyPackage {
  return { id: 0, package: new Uint8Array(0) };
}

export const GroupKeyPackage: MessageFns<GroupKeyPackage> = {
  encode(message: GroupKeyPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.package.length !== 0) {
      writer.uint32(18).bytes(message.package);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupKeyPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupKeyPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.package = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupKeyPackage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      package: isSet(object.package) ? bytesFromBase64(object.package) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupKeyPackage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.package.length !== 0) {
      obj.package = base64FromBytes(message.package);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupKeyPackage>, I>>(base?: I): GroupKeyPackage {
    return GroupKeyPackage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupKeyPackage>, I>>(object: I): GroupKeyPackage {
    const message = createBaseGroupKeyPackage();
    message.id = object.id ?? 0;
    message.package = object.package ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroupKeyPackages(): GroupKeyPackages {
  return { packages: [] };
}

export const GroupKeyPackages: MessageFns<GroupKeyPackages> = {
  encode(message: GroupKeyPackages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packages) {
      GroupKeyPackage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupKeyPackages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupKeyPackages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packages.push(GroupKeyPackage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupKeyPackages {
    return {
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => GroupKeyPackage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupKeyPackages): unknown {
    const obj: any = {};
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => GroupKeyPackage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupKeyPackages>, I>>(base?: I): GroupKeyPackages {
    return GroupKeyPackages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupKeyPackages>, I>>(object: I): GroupKeyPackages {
    const message = createBaseGroupKeyPackages();
    message.packages = object.packages?.map((e) => GroupKeyPackage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupMessages(): GroupMessages {
  return { messages: [] };
}

export const GroupMessages: MessageFns<GroupMessages> = {
  encode(message: GroupMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      GroupMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(GroupMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => GroupMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => GroupMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMessages>, I>>(base?: I): GroupMessages {
    return GroupMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMessages>, I>>(object: I): GroupMessages {
    const message = createBaseGroupMessages();
    message.messages = object.messages?.map((e) => GroupMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return { userMessage: undefined, groupMessage: undefined, userMessages: undefined, groupMessages: undefined };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
    }
    if (message.userMessages !== undefined) {
      UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
    }
    if (message.groupMessages !== undefined) {
      GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupMessage = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userMessages = UserMessages.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessages = GroupMessages.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupMessage.fromJSON(object.groupMessage) : undefined,
      userMessages: isSet(object.userMessages) ? UserMessages.fromJSON(object.userMessages) : undefined,
      groupMessages: isSet(object.groupMessages) ? GroupMessages.fromJSON(object.groupMessages) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupMessage.toJSON(message.groupMessage);
    }
    if (message.userMessages !== undefined) {
      obj.userMessages = UserMessages.toJSON(message.userMessages);
    }
    if (message.groupMessages !== undefined) {
      obj.groupMessages = GroupMessages.toJSON(message.groupMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupMessage.fromPartial(object.groupMessage)
      : undefined;
    message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
      ? UserMessages.fromPartial(object.userMessages)
      : undefined;
    message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
      ? GroupMessages.fromPartial(object.groupMessages)
      : undefined;
    return message;
  },
};

function createBaseSubscribeGroup(): SubscribeGroup {
  return { id: 0n };
}

export const SubscribeGroup: MessageFns<SubscribeGroup> = {
  encode(message: SubscribeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeGroup {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: SubscribeGroup): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeGroup>, I>>(base?: I): SubscribeGroup {
    return SubscribeGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeGroup>, I>>(object: I): SubscribeGroup {
    const message = createBaseSubscribeGroup();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseUnSubscribeGroup(): UnSubscribeGroup {
  return { id: 0n };
}

export const UnSubscribeGroup: MessageFns<UnSubscribeGroup> = {
  encode(message: UnSubscribeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnSubscribeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnSubscribeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnSubscribeGroup {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: UnSubscribeGroup): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnSubscribeGroup>, I>>(base?: I): UnSubscribeGroup {
    return UnSubscribeGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnSubscribeGroup>, I>>(object: I): UnSubscribeGroup {
    const message = createBaseUnSubscribeGroup();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseClientMessage(): ClientMessage {
  return {
    userMessage: undefined,
    groupMessage: undefined,
    userMessages: undefined,
    groupMessages: undefined,
    bearerToken: undefined,
    subscribeGroup: undefined,
    unSubscribeGroup: undefined,
  };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
    }
    if (message.userMessages !== undefined) {
      UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
    }
    if (message.groupMessages !== undefined) {
      GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
    }
    if (message.bearerToken !== undefined) {
      writer.uint32(42).string(message.bearerToken);
    }
    if (message.subscribeGroup !== undefined) {
      SubscribeGroup.encode(message.subscribeGroup, writer.uint32(50).fork()).join();
    }
    if (message.unSubscribeGroup !== undefined) {
      UnSubscribeGroup.encode(message.unSubscribeGroup, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupMessage = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userMessages = UserMessages.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessages = GroupMessages.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bearerToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscribeGroup = SubscribeGroup.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.unSubscribeGroup = UnSubscribeGroup.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupMessage.fromJSON(object.groupMessage) : undefined,
      userMessages: isSet(object.userMessages) ? UserMessages.fromJSON(object.userMessages) : undefined,
      groupMessages: isSet(object.groupMessages) ? GroupMessages.fromJSON(object.groupMessages) : undefined,
      bearerToken: isSet(object.bearerToken) ? globalThis.String(object.bearerToken) : undefined,
      subscribeGroup: isSet(object.subscribeGroup) ? SubscribeGroup.fromJSON(object.subscribeGroup) : undefined,
      unSubscribeGroup: isSet(object.unSubscribeGroup) ? UnSubscribeGroup.fromJSON(object.unSubscribeGroup) : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupMessage.toJSON(message.groupMessage);
    }
    if (message.userMessages !== undefined) {
      obj.userMessages = UserMessages.toJSON(message.userMessages);
    }
    if (message.groupMessages !== undefined) {
      obj.groupMessages = GroupMessages.toJSON(message.groupMessages);
    }
    if (message.bearerToken !== undefined) {
      obj.bearerToken = message.bearerToken;
    }
    if (message.subscribeGroup !== undefined) {
      obj.subscribeGroup = SubscribeGroup.toJSON(message.subscribeGroup);
    }
    if (message.unSubscribeGroup !== undefined) {
      obj.unSubscribeGroup = UnSubscribeGroup.toJSON(message.unSubscribeGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupMessage.fromPartial(object.groupMessage)
      : undefined;
    message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
      ? UserMessages.fromPartial(object.userMessages)
      : undefined;
    message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
      ? GroupMessages.fromPartial(object.groupMessages)
      : undefined;
    message.bearerToken = object.bearerToken ?? undefined;
    message.subscribeGroup = (object.subscribeGroup !== undefined && object.subscribeGroup !== null)
      ? SubscribeGroup.fromPartial(object.subscribeGroup)
      : undefined;
    message.unSubscribeGroup = (object.unSubscribeGroup !== undefined && object.unSubscribeGroup !== null)
      ? UnSubscribeGroup.fromPartial(object.unSubscribeGroup)
      : undefined;
    return message;
  },
};

function createBaseGroupId(): GroupId {
  return { id: 0n };
}

export const GroupId: MessageFns<GroupId> = {
  encode(message: GroupId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupId {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: GroupId): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupId>, I>>(base?: I): GroupId {
    return GroupId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupId>, I>>(object: I): GroupId {
    const message = createBaseGroupId();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseAuthToken(): AuthToken {
  return { username: "", validUntil: 0n, issuer: "", credential: new Uint8Array(0) };
}

export const AuthToken: MessageFns<AuthToken> = {
  encode(message: AuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.validUntil !== 0n) {
      if (BigInt.asUintN(64, message.validUntil) !== message.validUntil) {
        throw new globalThis.Error("value provided for field message.validUntil of type uint64 too large");
      }
      writer.uint32(16).uint64(message.validUntil);
    }
    if (message.issuer !== "") {
      writer.uint32(26).string(message.issuer);
    }
    if (message.credential.length !== 0) {
      writer.uint32(34).bytes(message.credential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.validUntil = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.credential = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthToken {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      validUntil: isSet(object.validUntil) ? BigInt(object.validUntil) : 0n,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
    };
  },

  toJSON(message: AuthToken): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.validUntil !== 0n) {
      obj.validUntil = message.validUntil.toString();
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.credential.length !== 0) {
      obj.credential = base64FromBytes(message.credential);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthToken>, I>>(base?: I): AuthToken {
    return AuthToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthToken>, I>>(object: I): AuthToken {
    const message = createBaseAuthToken();
    message.username = object.username ?? "";
    message.validUntil = object.validUntil ?? 0n;
    message.issuer = object.issuer ?? "";
    message.credential = object.credential ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSignedToken(): SignedToken {
  return { kid: "", payload: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const SignedToken: MessageFns<SignedToken> = {
  encode(message: SignedToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kid !== "") {
      writer.uint32(10).string(message.kid);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedToken {
    return {
      kid: isSet(object.kid) ? globalThis.String(object.kid) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: SignedToken): unknown {
    const obj: any = {};
    if (message.kid !== "") {
      obj.kid = message.kid;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedToken>, I>>(base?: I): SignedToken {
    return SignedToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedToken>, I>>(object: I): SignedToken {
    const message = createBaseSignedToken();
    message.kid = object.kid ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFireflyClient(): FireflyClient {
  return { username: "", secret: new Uint8Array(0), public: new Uint8Array(0), credential: new Uint8Array(0) };
}

export const FireflyClient: MessageFns<FireflyClient> = {
  encode(message: FireflyClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.secret.length !== 0) {
      writer.uint32(18).bytes(message.secret);
    }
    if (message.public.length !== 0) {
      writer.uint32(26).bytes(message.public);
    }
    if (message.credential.length !== 0) {
      writer.uint32(34).bytes(message.credential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.public = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.credential = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyClient {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : new Uint8Array(0),
      public: isSet(object.public) ? bytesFromBase64(object.public) : new Uint8Array(0),
      credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
    };
  },

  toJSON(message: FireflyClient): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.secret.length !== 0) {
      obj.secret = base64FromBytes(message.secret);
    }
    if (message.public.length !== 0) {
      obj.public = base64FromBytes(message.public);
    }
    if (message.credential.length !== 0) {
      obj.credential = base64FromBytes(message.credential);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyClient>, I>>(base?: I): FireflyClient {
    return FireflyClient.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyClient>, I>>(object: I): FireflyClient {
    const message = createBaseFireflyClient();
    message.username = object.username ?? "";
    message.secret = object.secret ?? new Uint8Array(0);
    message.public = object.public ?? new Uint8Array(0);
    message.credential = object.credential ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFireflyGroupExtension(): FireflyGroupExtension {
  return { name: "", roles: undefined, channels: undefined, members: undefined };
}

export const FireflyGroupExtension: MessageFns<FireflyGroupExtension> = {
  encode(message: FireflyGroupExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.roles !== undefined) {
      FireflyGroupRoles.encode(message.roles, writer.uint32(18).fork()).join();
    }
    if (message.channels !== undefined) {
      FireflyGroupChannels.encode(message.channels, writer.uint32(26).fork()).join();
    }
    if (message.members !== undefined) {
      FireflyGroupMembers.encode(message.members, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roles = FireflyGroupRoles.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channels = FireflyGroupChannels.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.members = FireflyGroupMembers.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupExtension {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roles: isSet(object.roles) ? FireflyGroupRoles.fromJSON(object.roles) : undefined,
      channels: isSet(object.channels) ? FireflyGroupChannels.fromJSON(object.channels) : undefined,
      members: isSet(object.members) ? FireflyGroupMembers.fromJSON(object.members) : undefined,
    };
  },

  toJSON(message: FireflyGroupExtension): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roles !== undefined) {
      obj.roles = FireflyGroupRoles.toJSON(message.roles);
    }
    if (message.channels !== undefined) {
      obj.channels = FireflyGroupChannels.toJSON(message.channels);
    }
    if (message.members !== undefined) {
      obj.members = FireflyGroupMembers.toJSON(message.members);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupExtension>, I>>(base?: I): FireflyGroupExtension {
    return FireflyGroupExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupExtension>, I>>(object: I): FireflyGroupExtension {
    const message = createBaseFireflyGroupExtension();
    message.name = object.name ?? "";
    message.roles = (object.roles !== undefined && object.roles !== null)
      ? FireflyGroupRoles.fromPartial(object.roles)
      : undefined;
    message.channels = (object.channels !== undefined && object.channels !== null)
      ? FireflyGroupChannels.fromPartial(object.channels)
      : undefined;
    message.members = (object.members !== undefined && object.members !== null)
      ? FireflyGroupMembers.fromPartial(object.members)
      : undefined;
    return message;
  },
};

function createBaseFireflyGroupRole(): FireflyGroupRole {
  return { id: 0, name: "", permissions: 0n };
}

export const FireflyGroupRole: MessageFns<FireflyGroupRole> = {
  encode(message: FireflyGroupRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.permissions !== 0n) {
      if (BigInt.asUintN(64, message.permissions) !== message.permissions) {
        throw new globalThis.Error("value provided for field message.permissions of type uint64 too large");
      }
      writer.uint32(24).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permissions = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupRole {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      permissions: isSet(object.permissions) ? BigInt(object.permissions) : 0n,
    };
  },

  toJSON(message: FireflyGroupRole): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.permissions !== 0n) {
      obj.permissions = message.permissions.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupRole>, I>>(base?: I): FireflyGroupRole {
    return FireflyGroupRole.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupRole>, I>>(object: I): FireflyGroupRole {
    const message = createBaseFireflyGroupRole();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.permissions = object.permissions ?? 0n;
    return message;
  },
};

function createBaseFireflyGroupRoles(): FireflyGroupRoles {
  return { roles: [] };
}

export const FireflyGroupRoles: MessageFns<FireflyGroupRoles> = {
  encode(message: FireflyGroupRoles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      FireflyGroupRole.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupRoles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupRoles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(FireflyGroupRole.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupRoles {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => FireflyGroupRole.fromJSON(e)) : [],
    };
  },

  toJSON(message: FireflyGroupRoles): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => FireflyGroupRole.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupRoles>, I>>(base?: I): FireflyGroupRoles {
    return FireflyGroupRoles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupRoles>, I>>(object: I): FireflyGroupRoles {
    const message = createBaseFireflyGroupRoles();
    message.roles = object.roles?.map((e) => FireflyGroupRole.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFireflyGroupMember(): FireflyGroupMember {
  return { username: "", role: 0 };
}

export const FireflyGroupMember: MessageFns<FireflyGroupMember> = {
  encode(message: FireflyGroupMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.role !== 0) {
      writer.uint32(16).uint32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupMember {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
    };
  },

  toJSON(message: FireflyGroupMember): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupMember>, I>>(base?: I): FireflyGroupMember {
    return FireflyGroupMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupMember>, I>>(object: I): FireflyGroupMember {
    const message = createBaseFireflyGroupMember();
    message.username = object.username ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseFireflyGroupMembers(): FireflyGroupMembers {
  return { members: [] };
}

export const FireflyGroupMembers: MessageFns<FireflyGroupMembers> = {
  encode(message: FireflyGroupMembers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      FireflyGroupMember.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupMembers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupMembers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(FireflyGroupMember.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupMembers {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => FireflyGroupMember.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FireflyGroupMembers): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => FireflyGroupMember.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupMembers>, I>>(base?: I): FireflyGroupMembers {
    return FireflyGroupMembers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupMembers>, I>>(object: I): FireflyGroupMembers {
    const message = createBaseFireflyGroupMembers();
    message.members = object.members?.map((e) => FireflyGroupMember.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFireflyGroupChannel(): FireflyGroupChannel {
  return { id: 0, name: "", type: 0, roles: undefined };
}

export const FireflyGroupChannel: MessageFns<FireflyGroupChannel> = {
  encode(message: FireflyGroupChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).uint32(message.type);
    }
    if (message.roles !== undefined) {
      FireflyGroupRoles.encode(message.roles, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roles = FireflyGroupRoles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupChannel {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      roles: isSet(object.roles) ? FireflyGroupRoles.fromJSON(object.roles) : undefined,
    };
  },

  toJSON(message: FireflyGroupChannel): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.roles !== undefined) {
      obj.roles = FireflyGroupRoles.toJSON(message.roles);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupChannel>, I>>(base?: I): FireflyGroupChannel {
    return FireflyGroupChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupChannel>, I>>(object: I): FireflyGroupChannel {
    const message = createBaseFireflyGroupChannel();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.roles = (object.roles !== undefined && object.roles !== null)
      ? FireflyGroupRoles.fromPartial(object.roles)
      : undefined;
    return message;
  },
};

function createBaseFireflyGroupChannels(): FireflyGroupChannels {
  return { channels: [] };
}

export const FireflyGroupChannels: MessageFns<FireflyGroupChannels> = {
  encode(message: FireflyGroupChannels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channels) {
      FireflyGroupChannel.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupChannels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupChannels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channels.push(FireflyGroupChannel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupChannels {
    return {
      channels: globalThis.Array.isArray(object?.channels)
        ? object.channels.map((e: any) => FireflyGroupChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FireflyGroupChannels): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => FireflyGroupChannel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupChannels>, I>>(base?: I): FireflyGroupChannels {
    return FireflyGroupChannels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupChannels>, I>>(object: I): FireflyGroupChannels {
    const message = createBaseFireflyGroupChannels();
    message.channels = object.channels?.map((e) => FireflyGroupChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBasePreKeyBundle(): PreKeyBundle {
  return {
    registrationId: 0,
    deviceId: 0,
    preKeyId: 0,
    prePublicKey: new Uint8Array(0),
    signedPreKeyId: 0,
    signedPrePublicKey: new Uint8Array(0),
    signedPreKeySignature: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
    KEMPreKeyId: 0,
    KEMPrePublicKey: new Uint8Array(0),
    KEMPreKeySignature: new Uint8Array(0),
  };
}

export const PreKeyBundle: MessageFns<PreKeyBundle> = {
  encode(message: PreKeyBundle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registrationId !== 0) {
      writer.uint32(8).int32(message.registrationId);
    }
    if (message.deviceId !== 0) {
      writer.uint32(16).int32(message.deviceId);
    }
    if (message.preKeyId !== 0) {
      writer.uint32(24).int32(message.preKeyId);
    }
    if (message.prePublicKey.length !== 0) {
      writer.uint32(34).bytes(message.prePublicKey);
    }
    if (message.signedPreKeyId !== 0) {
      writer.uint32(40).int32(message.signedPreKeyId);
    }
    if (message.signedPrePublicKey.length !== 0) {
      writer.uint32(50).bytes(message.signedPrePublicKey);
    }
    if (message.signedPreKeySignature.length !== 0) {
      writer.uint32(58).bytes(message.signedPreKeySignature);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.identityPublicKey);
    }
    if (message.KEMPreKeyId !== 0) {
      writer.uint32(72).int32(message.KEMPreKeyId);
    }
    if (message.KEMPrePublicKey.length !== 0) {
      writer.uint32(82).bytes(message.KEMPrePublicKey);
    }
    if (message.KEMPreKeySignature.length !== 0) {
      writer.uint32(90).bytes(message.KEMPreKeySignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.registrationId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deviceId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preKeyId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prePublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.signedPreKeyId = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signedPrePublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.signedPreKeySignature = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.KEMPreKeyId = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.KEMPrePublicKey = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.KEMPreKeySignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundle {
    return {
      registrationId: isSet(object.registrationId) ? globalThis.Number(object.registrationId) : 0,
      deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
      preKeyId: isSet(object.preKeyId) ? globalThis.Number(object.preKeyId) : 0,
      prePublicKey: isSet(object.prePublicKey) ? bytesFromBase64(object.prePublicKey) : new Uint8Array(0),
      signedPreKeyId: isSet(object.signedPreKeyId) ? globalThis.Number(object.signedPreKeyId) : 0,
      signedPrePublicKey: isSet(object.signedPrePublicKey)
        ? bytesFromBase64(object.signedPrePublicKey)
        : new Uint8Array(0),
      signedPreKeySignature: isSet(object.signedPreKeySignature)
        ? bytesFromBase64(object.signedPreKeySignature)
        : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      KEMPreKeyId: isSet(object.KEMPreKeyId) ? globalThis.Number(object.KEMPreKeyId) : 0,
      KEMPrePublicKey: isSet(object.KEMPrePublicKey) ? bytesFromBase64(object.KEMPrePublicKey) : new Uint8Array(0),
      KEMPreKeySignature: isSet(object.KEMPreKeySignature)
        ? bytesFromBase64(object.KEMPreKeySignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PreKeyBundle): unknown {
    const obj: any = {};
    if (message.registrationId !== 0) {
      obj.registrationId = Math.round(message.registrationId);
    }
    if (message.deviceId !== 0) {
      obj.deviceId = Math.round(message.deviceId);
    }
    if (message.preKeyId !== 0) {
      obj.preKeyId = Math.round(message.preKeyId);
    }
    if (message.prePublicKey.length !== 0) {
      obj.prePublicKey = base64FromBytes(message.prePublicKey);
    }
    if (message.signedPreKeyId !== 0) {
      obj.signedPreKeyId = Math.round(message.signedPreKeyId);
    }
    if (message.signedPrePublicKey.length !== 0) {
      obj.signedPrePublicKey = base64FromBytes(message.signedPrePublicKey);
    }
    if (message.signedPreKeySignature.length !== 0) {
      obj.signedPreKeySignature = base64FromBytes(message.signedPreKeySignature);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.KEMPreKeyId !== 0) {
      obj.KEMPreKeyId = Math.round(message.KEMPreKeyId);
    }
    if (message.KEMPrePublicKey.length !== 0) {
      obj.KEMPrePublicKey = base64FromBytes(message.KEMPrePublicKey);
    }
    if (message.KEMPreKeySignature.length !== 0) {
      obj.KEMPreKeySignature = base64FromBytes(message.KEMPreKeySignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundle>, I>>(base?: I): PreKeyBundle {
    return PreKeyBundle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundle>, I>>(object: I): PreKeyBundle {
    const message = createBasePreKeyBundle();
    message.registrationId = object.registrationId ?? 0;
    message.deviceId = object.deviceId ?? 0;
    message.preKeyId = object.preKeyId ?? 0;
    message.prePublicKey = object.prePublicKey ?? new Uint8Array(0);
    message.signedPreKeyId = object.signedPreKeyId ?? 0;
    message.signedPrePublicKey = object.signedPrePublicKey ?? new Uint8Array(0);
    message.signedPreKeySignature = object.signedPreKeySignature ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.KEMPreKeyId = object.KEMPreKeyId ?? 0;
    message.KEMPrePublicKey = object.KEMPrePublicKey ?? new Uint8Array(0);
    message.KEMPreKeySignature = object.KEMPreKeySignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseConversationStart(): ConversationStart {
  return { conversationId: 0n, startedBy: "", other: "", bundle: undefined };
}

export const ConversationStart: MessageFns<ConversationStart> = {
  encode(message: ConversationStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== 0n) {
      if (BigInt.asUintN(64, message.conversationId) !== message.conversationId) {
        throw new globalThis.Error("value provided for field message.conversationId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.conversationId);
    }
    if (message.startedBy !== "") {
      writer.uint32(18).string(message.startedBy);
    }
    if (message.other !== "") {
      writer.uint32(26).string(message.other);
    }
    if (message.bundle !== undefined) {
      PreKeyBundle.encode(message.bundle, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.conversationId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startedBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.other = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bundle = PreKeyBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationStart {
    return {
      conversationId: isSet(object.conversationId) ? BigInt(object.conversationId) : 0n,
      startedBy: isSet(object.startedBy) ? globalThis.String(object.startedBy) : "",
      other: isSet(object.other) ? globalThis.String(object.other) : "",
      bundle: isSet(object.bundle) ? PreKeyBundle.fromJSON(object.bundle) : undefined,
    };
  },

  toJSON(message: ConversationStart): unknown {
    const obj: any = {};
    if (message.conversationId !== 0n) {
      obj.conversationId = message.conversationId.toString();
    }
    if (message.startedBy !== "") {
      obj.startedBy = message.startedBy;
    }
    if (message.other !== "") {
      obj.other = message.other;
    }
    if (message.bundle !== undefined) {
      obj.bundle = PreKeyBundle.toJSON(message.bundle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationStart>, I>>(base?: I): ConversationStart {
    return ConversationStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationStart>, I>>(object: I): ConversationStart {
    const message = createBaseConversationStart();
    message.conversationId = object.conversationId ?? 0n;
    message.startedBy = object.startedBy ?? "";
    message.other = object.other ?? "";
    message.bundle = (object.bundle !== undefined && object.bundle !== null)
      ? PreKeyBundle.fromPartial(object.bundle)
      : undefined;
    return message;
  },
};

function createBasePreKeyBundles(): PreKeyBundles {
  return { bundles: [] };
}

export const PreKeyBundles: MessageFns<PreKeyBundles> = {
  encode(message: PreKeyBundles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bundles) {
      PreKeyBundle.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bundles.push(PreKeyBundle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundles {
    return {
      bundles: globalThis.Array.isArray(object?.bundles)
        ? object.bundles.map((e: any) => PreKeyBundle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PreKeyBundles): unknown {
    const obj: any = {};
    if (message.bundles?.length) {
      obj.bundles = message.bundles.map((e) => PreKeyBundle.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundles>, I>>(base?: I): PreKeyBundles {
    return PreKeyBundles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundles>, I>>(object: I): PreKeyBundles {
    const message = createBasePreKeyBundles();
    message.bundles = object.bundles?.map((e) => PreKeyBundle.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversation(): Conversation {
  return { id: 0n, startedBy: "", other: "" };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.startedBy !== "") {
      writer.uint32(18).string(message.startedBy);
    }
    if (message.other !== "") {
      writer.uint32(26).string(message.other);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startedBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.other = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      startedBy: isSet(object.startedBy) ? globalThis.String(object.startedBy) : "",
      other: isSet(object.other) ? globalThis.String(object.other) : "",
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.startedBy !== "") {
      obj.startedBy = message.startedBy;
    }
    if (message.other !== "") {
      obj.other = message.other;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(base?: I): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(object: I): Conversation {
    const message = createBaseConversation();
    message.id = object.id ?? 0n;
    message.startedBy = object.startedBy ?? "";
    message.other = object.other ?? "";
    return message;
  },
};

function createBaseConversations(): Conversations {
  return { conversations: [] };
}

export const Conversations: MessageFns<Conversations> = {
  encode(message: Conversations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversations {
    return {
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Conversations): unknown {
    const obj: any = {};
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversations>, I>>(base?: I): Conversations {
    return Conversations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversations>, I>>(object: I): Conversations {
    const message = createBaseConversations();
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserMessageInner(): UserMessageInner {
  return { plainText: undefined, callMessage: undefined };
}

export const UserMessageInner: MessageFns<UserMessageInner> = {
  encode(message: UserMessageInner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plainText !== undefined) {
      writer.uint32(10).bytes(message.plainText);
    }
    if (message.callMessage !== undefined) {
      writer.uint32(18).bytes(message.callMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessageInner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessageInner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plainText = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callMessage = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessageInner {
    return {
      plainText: isSet(object.plainText) ? bytesFromBase64(object.plainText) : undefined,
      callMessage: isSet(object.callMessage) ? bytesFromBase64(object.callMessage) : undefined,
    };
  },

  toJSON(message: UserMessageInner): unknown {
    const obj: any = {};
    if (message.plainText !== undefined) {
      obj.plainText = base64FromBytes(message.plainText);
    }
    if (message.callMessage !== undefined) {
      obj.callMessage = base64FromBytes(message.callMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessageInner>, I>>(base?: I): UserMessageInner {
    return UserMessageInner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessageInner>, I>>(object: I): UserMessageInner {
    const message = createBaseUserMessageInner();
    message.plainText = object.plainText ?? undefined;
    message.callMessage = object.callMessage ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
