// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "firefly";

export interface VersionedMessage {
  version: number;
  ts: bigint;
  data: Uint8Array;
}

export interface AuthenticationToken {
  token: string;
}

export interface GroupChats {
  chats: GroupChat[];
}

export interface GroupChannel {
  groupId: number;
  channelId: number;
  channelType: number;
  name: string;
}

export interface GroupChat {
  name: string;
  groupId: number;
  channels: GroupChannel[];
}

export interface GetGroupMembers {
  groupId: number;
  channelId: number;
}

export interface GetGroupMessages {
  groupId: number;
  channelId: number;
  before: Uint8Array;
  count: number;
}

export interface AddUser {
  username: string;
  groupId: number;
  channelId: number;
  role: number;
}

export interface RemoveUser {
  username: string;
  channelId: number;
  groupId: number;
}

export interface GroupMember {
  username: string;
  lastSeen: bigint;
  isOnline: boolean;
  role: number;
  chanId: number;
}

export interface GroupChannelMessage {
  id: Uint8Array;
  groupId: number;
  channelId: number;
  content: string;
  by: string;
}

export interface GroupChannelMessages {
  messages: GroupChannelMessage[];
}

export interface GroupMembers {
  members: GroupMember[];
}

export interface GetUserMessages {
  before: Uint8Array;
  count: number;
  from: string;
}

export interface Request {
  id: number;
  getGroupMembers?: GetGroupMembers | undefined;
  getGroupMessages?: GetGroupMessages | undefined;
  addUser?: AddUser | undefined;
  removeUser?: RemoveUser | undefined;
  addChannel?: GroupChannel | undefined;
  deleteChannel?: GroupChannel | undefined;
  getUserMessages?: GetUserMessages | undefined;
}

export interface Error {
  status: number;
  error: string;
}

export interface Response {
  id: number;
  error?: Error | undefined;
  groupMembers?: GroupMembers | undefined;
  groupMessages?: GroupChannelMessages | undefined;
  userMessages?: UserMessages | undefined;
  channel?: GroupChannel | undefined;
}

export interface ClientMessage {
  request?: Request | undefined;
  groupMessage?: GroupChannelMessage | undefined;
  authToken?: AuthenticationToken | undefined;
  currentGroup?: number | undefined;
  userMessage?: UserMessage | undefined;
}

export interface ServerMessage {
  response?: Response | undefined;
  groupChats?: GroupChats | undefined;
  groupChat?: GroupChat | undefined;
  groupMessage?: GroupChannelMessage | undefined;
  userMessage?: UserMessage | undefined;
  userChats?: UserMessages | undefined;
}

export interface UserMessage {
  id: Uint8Array;
  version: number;
  text: string;
  to: string;
  from: string;
}

export interface UserMessages {
  messages: UserMessage[];
}

function createBaseVersionedMessage(): VersionedMessage {
  return { version: 0, ts: 0n, data: new Uint8Array(0) };
}

export const VersionedMessage: MessageFns<VersionedMessage> = {
  encode(message: VersionedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.ts !== 0n) {
      if (BigInt.asUintN(64, message.ts) !== message.ts) {
        throw new globalThis.Error("value provided for field message.ts of type uint64 too large");
      }
      writer.uint32(16).uint64(message.ts);
    }
    if (message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ts = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionedMessage {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      ts: isSet(object.ts) ? BigInt(object.ts) : 0n,
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: VersionedMessage): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.ts !== 0n) {
      obj.ts = message.ts.toString();
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionedMessage>, I>>(base?: I): VersionedMessage {
    return VersionedMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionedMessage>, I>>(object: I): VersionedMessage {
    const message = createBaseVersionedMessage();
    message.version = object.version ?? 0;
    message.ts = object.ts ?? 0n;
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthenticationToken(): AuthenticationToken {
  return { token: "" };
}

export const AuthenticationToken: MessageFns<AuthenticationToken> = {
  encode(message: AuthenticationToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationToken {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: AuthenticationToken): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationToken>, I>>(base?: I): AuthenticationToken {
    return AuthenticationToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationToken>, I>>(object: I): AuthenticationToken {
    const message = createBaseAuthenticationToken();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseGroupChats(): GroupChats {
  return { chats: [] };
}

export const GroupChats: MessageFns<GroupChats> = {
  encode(message: GroupChats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chats) {
      GroupChat.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chats.push(GroupChat.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupChats {
    return {
      chats: globalThis.Array.isArray(object?.chats) ? object.chats.map((e: any) => GroupChat.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupChats): unknown {
    const obj: any = {};
    if (message.chats?.length) {
      obj.chats = message.chats.map((e) => GroupChat.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupChats>, I>>(base?: I): GroupChats {
    return GroupChats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChats>, I>>(object: I): GroupChats {
    const message = createBaseGroupChats();
    message.chats = object.chats?.map((e) => GroupChat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupChannel(): GroupChannel {
  return { groupId: 0, channelId: 0, channelType: 0, name: "" };
}

export const GroupChannel: MessageFns<GroupChannel> = {
  encode(message: GroupChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0) {
      writer.uint32(8).int32(message.groupId);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).int32(message.channelId);
    }
    if (message.channelType !== 0) {
      writer.uint32(24).int32(message.channelType);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channelType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupChannel {
    return {
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      channelType: isSet(object.channelType) ? globalThis.Number(object.channelType) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GroupChannel): unknown {
    const obj: any = {};
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.channelType !== 0) {
      obj.channelType = Math.round(message.channelType);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupChannel>, I>>(base?: I): GroupChannel {
    return GroupChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChannel>, I>>(object: I): GroupChannel {
    const message = createBaseGroupChannel();
    message.groupId = object.groupId ?? 0;
    message.channelId = object.channelId ?? 0;
    message.channelType = object.channelType ?? 0;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGroupChat(): GroupChat {
  return { name: "", groupId: 0, channels: [] };
}

export const GroupChat: MessageFns<GroupChat> = {
  encode(message: GroupChat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.groupId !== 0) {
      writer.uint32(16).int32(message.groupId);
    }
    for (const v of message.channels) {
      GroupChannel.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channels.push(GroupChannel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupChat {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channels: globalThis.Array.isArray(object?.channels)
        ? object.channels.map((e: any) => GroupChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupChat): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => GroupChannel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupChat>, I>>(base?: I): GroupChat {
    return GroupChat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChat>, I>>(object: I): GroupChat {
    const message = createBaseGroupChat();
    message.name = object.name ?? "";
    message.groupId = object.groupId ?? 0;
    message.channels = object.channels?.map((e) => GroupChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetGroupMembers(): GetGroupMembers {
  return { groupId: 0, channelId: 0 };
}

export const GetGroupMembers: MessageFns<GetGroupMembers> = {
  encode(message: GetGroupMembers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0) {
      writer.uint32(8).int32(message.groupId);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).int32(message.channelId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMembers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMembers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMembers {
    return {
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
    };
  },

  toJSON(message: GetGroupMembers): unknown {
    const obj: any = {};
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMembers>, I>>(base?: I): GetGroupMembers {
    return GetGroupMembers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMembers>, I>>(object: I): GetGroupMembers {
    const message = createBaseGetGroupMembers();
    message.groupId = object.groupId ?? 0;
    message.channelId = object.channelId ?? 0;
    return message;
  },
};

function createBaseGetGroupMessages(): GetGroupMessages {
  return { groupId: 0, channelId: 0, before: new Uint8Array(0), count: 0 };
}

export const GetGroupMessages: MessageFns<GetGroupMessages> = {
  encode(message: GetGroupMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0) {
      writer.uint32(8).int32(message.groupId);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).int32(message.channelId);
    }
    if (message.before.length !== 0) {
      writer.uint32(26).bytes(message.before);
    }
    if (message.count !== 0) {
      writer.uint32(32).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGroupMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGroupMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.before = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGroupMessages {
    return {
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      before: isSet(object.before) ? bytesFromBase64(object.before) : new Uint8Array(0),
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: GetGroupMessages): unknown {
    const obj: any = {};
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.before.length !== 0) {
      obj.before = base64FromBytes(message.before);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetGroupMessages>, I>>(base?: I): GetGroupMessages {
    return GetGroupMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetGroupMessages>, I>>(object: I): GetGroupMessages {
    const message = createBaseGetGroupMessages();
    message.groupId = object.groupId ?? 0;
    message.channelId = object.channelId ?? 0;
    message.before = object.before ?? new Uint8Array(0);
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseAddUser(): AddUser {
  return { username: "", groupId: 0, channelId: 0, role: 0 };
}

export const AddUser: MessageFns<AddUser> = {
  encode(message: AddUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.groupId !== 0) {
      writer.uint32(16).int32(message.groupId);
    }
    if (message.channelId !== 0) {
      writer.uint32(24).int32(message.channelId);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.role = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUser {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
    };
  },

  toJSON(message: AddUser): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUser>, I>>(base?: I): AddUser {
    return AddUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUser>, I>>(object: I): AddUser {
    const message = createBaseAddUser();
    message.username = object.username ?? "";
    message.groupId = object.groupId ?? 0;
    message.channelId = object.channelId ?? 0;
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseRemoveUser(): RemoveUser {
  return { username: "", channelId: 0, groupId: 0 };
}

export const RemoveUser: MessageFns<RemoveUser> = {
  encode(message: RemoveUser, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.channelId !== 0) {
      writer.uint32(16).int32(message.channelId);
    }
    if (message.groupId !== 0) {
      writer.uint32(24).int32(message.groupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveUser {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUser {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
    };
  },

  toJSON(message: RemoveUser): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUser>, I>>(base?: I): RemoveUser {
    return RemoveUser.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUser>, I>>(object: I): RemoveUser {
    const message = createBaseRemoveUser();
    message.username = object.username ?? "";
    message.channelId = object.channelId ?? 0;
    message.groupId = object.groupId ?? 0;
    return message;
  },
};

function createBaseGroupMember(): GroupMember {
  return { username: "", lastSeen: 0n, isOnline: false, role: 0, chanId: 0 };
}

export const GroupMember: MessageFns<GroupMember> = {
  encode(message: GroupMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.lastSeen !== 0n) {
      if (BigInt.asUintN(64, message.lastSeen) !== message.lastSeen) {
        throw new globalThis.Error("value provided for field message.lastSeen of type uint64 too large");
      }
      writer.uint32(16).uint64(message.lastSeen);
    }
    if (message.isOnline !== false) {
      writer.uint32(24).bool(message.isOnline);
    }
    if (message.role !== 0) {
      writer.uint32(32).int32(message.role);
    }
    if (message.chanId !== 0) {
      writer.uint32(40).int32(message.chanId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lastSeen = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isOnline = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.role = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.chanId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMember {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      lastSeen: isSet(object.lastSeen) ? BigInt(object.lastSeen) : 0n,
      isOnline: isSet(object.isOnline) ? globalThis.Boolean(object.isOnline) : false,
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
      chanId: isSet(object.chanId) ? globalThis.Number(object.chanId) : 0,
    };
  },

  toJSON(message: GroupMember): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.lastSeen !== 0n) {
      obj.lastSeen = message.lastSeen.toString();
    }
    if (message.isOnline !== false) {
      obj.isOnline = message.isOnline;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    if (message.chanId !== 0) {
      obj.chanId = Math.round(message.chanId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMember>, I>>(base?: I): GroupMember {
    return GroupMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMember>, I>>(object: I): GroupMember {
    const message = createBaseGroupMember();
    message.username = object.username ?? "";
    message.lastSeen = object.lastSeen ?? 0n;
    message.isOnline = object.isOnline ?? false;
    message.role = object.role ?? 0;
    message.chanId = object.chanId ?? 0;
    return message;
  },
};

function createBaseGroupChannelMessage(): GroupChannelMessage {
  return { id: new Uint8Array(0), groupId: 0, channelId: 0, content: "", by: "" };
}

export const GroupChannelMessage: MessageFns<GroupChannelMessage> = {
  encode(message: GroupChannelMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.groupId !== 0) {
      writer.uint32(16).int32(message.groupId);
    }
    if (message.channelId !== 0) {
      writer.uint32(24).int32(message.channelId);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.by !== "") {
      writer.uint32(42).string(message.by);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.channelId = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.by = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupChannelMessage {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      groupId: isSet(object.groupId) ? globalThis.Number(object.groupId) : 0,
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      by: isSet(object.by) ? globalThis.String(object.by) : "",
    };
  },

  toJSON(message: GroupChannelMessage): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.groupId !== 0) {
      obj.groupId = Math.round(message.groupId);
    }
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.by !== "") {
      obj.by = message.by;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupChannelMessage>, I>>(base?: I): GroupChannelMessage {
    return GroupChannelMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChannelMessage>, I>>(object: I): GroupChannelMessage {
    const message = createBaseGroupChannelMessage();
    message.id = object.id ?? new Uint8Array(0);
    message.groupId = object.groupId ?? 0;
    message.channelId = object.channelId ?? 0;
    message.content = object.content ?? "";
    message.by = object.by ?? "";
    return message;
  },
};

function createBaseGroupChannelMessages(): GroupChannelMessages {
  return { messages: [] };
}

export const GroupChannelMessages: MessageFns<GroupChannelMessages> = {
  encode(message: GroupChannelMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      GroupChannelMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupChannelMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupChannelMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(GroupChannelMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupChannelMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => GroupChannelMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupChannelMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => GroupChannelMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupChannelMessages>, I>>(base?: I): GroupChannelMessages {
    return GroupChannelMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupChannelMessages>, I>>(object: I): GroupChannelMessages {
    const message = createBaseGroupChannelMessages();
    message.messages = object.messages?.map((e) => GroupChannelMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupMembers(): GroupMembers {
  return { members: [] };
}

export const GroupMembers: MessageFns<GroupMembers> = {
  encode(message: GroupMembers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      GroupMember.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMembers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMembers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(GroupMember.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMembers {
    return {
      members: globalThis.Array.isArray(object?.members) ? object.members.map((e: any) => GroupMember.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupMembers): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => GroupMember.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMembers>, I>>(base?: I): GroupMembers {
    return GroupMembers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMembers>, I>>(object: I): GroupMembers {
    const message = createBaseGroupMembers();
    message.members = object.members?.map((e) => GroupMember.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetUserMessages(): GetUserMessages {
  return { before: new Uint8Array(0), count: 0, from: "" };
}

export const GetUserMessages: MessageFns<GetUserMessages> = {
  encode(message: GetUserMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.before.length !== 0) {
      writer.uint32(10).bytes(message.before);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    if (message.from !== "") {
      writer.uint32(26).string(message.from);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetUserMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.before = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.from = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetUserMessages {
    return {
      before: isSet(object.before) ? bytesFromBase64(object.before) : new Uint8Array(0),
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      from: isSet(object.from) ? globalThis.String(object.from) : "",
    };
  },

  toJSON(message: GetUserMessages): unknown {
    const obj: any = {};
    if (message.before.length !== 0) {
      obj.before = base64FromBytes(message.before);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetUserMessages>, I>>(base?: I): GetUserMessages {
    return GetUserMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetUserMessages>, I>>(object: I): GetUserMessages {
    const message = createBaseGetUserMessages();
    message.before = object.before ?? new Uint8Array(0);
    message.count = object.count ?? 0;
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseRequest(): Request {
  return {
    id: 0,
    getGroupMembers: undefined,
    getGroupMessages: undefined,
    addUser: undefined,
    removeUser: undefined,
    addChannel: undefined,
    deleteChannel: undefined,
    getUserMessages: undefined,
  };
}

export const Request: MessageFns<Request> = {
  encode(message: Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.getGroupMembers !== undefined) {
      GetGroupMembers.encode(message.getGroupMembers, writer.uint32(18).fork()).join();
    }
    if (message.getGroupMessages !== undefined) {
      GetGroupMessages.encode(message.getGroupMessages, writer.uint32(26).fork()).join();
    }
    if (message.addUser !== undefined) {
      AddUser.encode(message.addUser, writer.uint32(34).fork()).join();
    }
    if (message.removeUser !== undefined) {
      RemoveUser.encode(message.removeUser, writer.uint32(42).fork()).join();
    }
    if (message.addChannel !== undefined) {
      GroupChannel.encode(message.addChannel, writer.uint32(50).fork()).join();
    }
    if (message.deleteChannel !== undefined) {
      GroupChannel.encode(message.deleteChannel, writer.uint32(58).fork()).join();
    }
    if (message.getUserMessages !== undefined) {
      GetUserMessages.encode(message.getUserMessages, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getGroupMembers = GetGroupMembers.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.getGroupMessages = GetGroupMessages.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addUser = AddUser.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.removeUser = RemoveUser.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.addChannel = GroupChannel.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.deleteChannel = GroupChannel.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.getUserMessages = GetUserMessages.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      getGroupMembers: isSet(object.getGroupMembers) ? GetGroupMembers.fromJSON(object.getGroupMembers) : undefined,
      getGroupMessages: isSet(object.getGroupMessages) ? GetGroupMessages.fromJSON(object.getGroupMessages) : undefined,
      addUser: isSet(object.addUser) ? AddUser.fromJSON(object.addUser) : undefined,
      removeUser: isSet(object.removeUser) ? RemoveUser.fromJSON(object.removeUser) : undefined,
      addChannel: isSet(object.addChannel) ? GroupChannel.fromJSON(object.addChannel) : undefined,
      deleteChannel: isSet(object.deleteChannel) ? GroupChannel.fromJSON(object.deleteChannel) : undefined,
      getUserMessages: isSet(object.getUserMessages) ? GetUserMessages.fromJSON(object.getUserMessages) : undefined,
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.getGroupMembers !== undefined) {
      obj.getGroupMembers = GetGroupMembers.toJSON(message.getGroupMembers);
    }
    if (message.getGroupMessages !== undefined) {
      obj.getGroupMessages = GetGroupMessages.toJSON(message.getGroupMessages);
    }
    if (message.addUser !== undefined) {
      obj.addUser = AddUser.toJSON(message.addUser);
    }
    if (message.removeUser !== undefined) {
      obj.removeUser = RemoveUser.toJSON(message.removeUser);
    }
    if (message.addChannel !== undefined) {
      obj.addChannel = GroupChannel.toJSON(message.addChannel);
    }
    if (message.deleteChannel !== undefined) {
      obj.deleteChannel = GroupChannel.toJSON(message.deleteChannel);
    }
    if (message.getUserMessages !== undefined) {
      obj.getUserMessages = GetUserMessages.toJSON(message.getUserMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Request>, I>>(base?: I): Request {
    return Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest();
    message.id = object.id ?? 0;
    message.getGroupMembers = (object.getGroupMembers !== undefined && object.getGroupMembers !== null)
      ? GetGroupMembers.fromPartial(object.getGroupMembers)
      : undefined;
    message.getGroupMessages = (object.getGroupMessages !== undefined && object.getGroupMessages !== null)
      ? GetGroupMessages.fromPartial(object.getGroupMessages)
      : undefined;
    message.addUser = (object.addUser !== undefined && object.addUser !== null)
      ? AddUser.fromPartial(object.addUser)
      : undefined;
    message.removeUser = (object.removeUser !== undefined && object.removeUser !== null)
      ? RemoveUser.fromPartial(object.removeUser)
      : undefined;
    message.addChannel = (object.addChannel !== undefined && object.addChannel !== null)
      ? GroupChannel.fromPartial(object.addChannel)
      : undefined;
    message.deleteChannel = (object.deleteChannel !== undefined && object.deleteChannel !== null)
      ? GroupChannel.fromPartial(object.deleteChannel)
      : undefined;
    message.getUserMessages = (object.getUserMessages !== undefined && object.getUserMessages !== null)
      ? GetUserMessages.fromPartial(object.getUserMessages)
      : undefined;
    return message;
  },
};

function createBaseError(): Error {
  return { status: 0, error: "" };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.status = object.status ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseResponse(): Response {
  return {
    id: 0,
    error: undefined,
    groupMembers: undefined,
    groupMessages: undefined,
    userMessages: undefined,
    channel: undefined,
  };
}

export const Response: MessageFns<Response> = {
  encode(message: Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.groupMembers !== undefined) {
      GroupMembers.encode(message.groupMembers, writer.uint32(26).fork()).join();
    }
    if (message.groupMessages !== undefined) {
      GroupChannelMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
    }
    if (message.userMessages !== undefined) {
      UserMessages.encode(message.userMessages, writer.uint32(42).fork()).join();
    }
    if (message.channel !== undefined) {
      GroupChannel.encode(message.channel, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupMembers = GroupMembers.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessages = GroupChannelMessages.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userMessages = UserMessages.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.channel = GroupChannel.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Response {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      groupMembers: isSet(object.groupMembers) ? GroupMembers.fromJSON(object.groupMembers) : undefined,
      groupMessages: isSet(object.groupMessages) ? GroupChannelMessages.fromJSON(object.groupMessages) : undefined,
      userMessages: isSet(object.userMessages) ? UserMessages.fromJSON(object.userMessages) : undefined,
      channel: isSet(object.channel) ? GroupChannel.fromJSON(object.channel) : undefined,
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.groupMembers !== undefined) {
      obj.groupMembers = GroupMembers.toJSON(message.groupMembers);
    }
    if (message.groupMessages !== undefined) {
      obj.groupMessages = GroupChannelMessages.toJSON(message.groupMessages);
    }
    if (message.userMessages !== undefined) {
      obj.userMessages = UserMessages.toJSON(message.userMessages);
    }
    if (message.channel !== undefined) {
      obj.channel = GroupChannel.toJSON(message.channel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.id = object.id ?? 0;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.groupMembers = (object.groupMembers !== undefined && object.groupMembers !== null)
      ? GroupMembers.fromPartial(object.groupMembers)
      : undefined;
    message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
      ? GroupChannelMessages.fromPartial(object.groupMessages)
      : undefined;
    message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
      ? UserMessages.fromPartial(object.userMessages)
      : undefined;
    message.channel = (object.channel !== undefined && object.channel !== null)
      ? GroupChannel.fromPartial(object.channel)
      : undefined;
    return message;
  },
};

function createBaseClientMessage(): ClientMessage {
  return {
    request: undefined,
    groupMessage: undefined,
    authToken: undefined,
    currentGroup: undefined,
    userMessage: undefined,
  };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.request !== undefined) {
      Request.encode(message.request, writer.uint32(18).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupChannelMessage.encode(message.groupMessage, writer.uint32(26).fork()).join();
    }
    if (message.authToken !== undefined) {
      AuthenticationToken.encode(message.authToken, writer.uint32(34).fork()).join();
    }
    if (message.currentGroup !== undefined) {
      writer.uint32(40).int32(message.currentGroup);
    }
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.request = Request.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupMessage = GroupChannelMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authToken = AuthenticationToken.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.currentGroup = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      request: isSet(object.request) ? Request.fromJSON(object.request) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupChannelMessage.fromJSON(object.groupMessage) : undefined,
      authToken: isSet(object.authToken) ? AuthenticationToken.fromJSON(object.authToken) : undefined,
      currentGroup: isSet(object.currentGroup) ? globalThis.Number(object.currentGroup) : undefined,
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.request !== undefined) {
      obj.request = Request.toJSON(message.request);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupChannelMessage.toJSON(message.groupMessage);
    }
    if (message.authToken !== undefined) {
      obj.authToken = AuthenticationToken.toJSON(message.authToken);
    }
    if (message.currentGroup !== undefined) {
      obj.currentGroup = Math.round(message.currentGroup);
    }
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.request = (object.request !== undefined && object.request !== null)
      ? Request.fromPartial(object.request)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupChannelMessage.fromPartial(object.groupMessage)
      : undefined;
    message.authToken = (object.authToken !== undefined && object.authToken !== null)
      ? AuthenticationToken.fromPartial(object.authToken)
      : undefined;
    message.currentGroup = object.currentGroup ?? undefined;
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return {
    response: undefined,
    groupChats: undefined,
    groupChat: undefined,
    groupMessage: undefined,
    userMessage: undefined,
    userChats: undefined,
  };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      Response.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.groupChats !== undefined) {
      GroupChats.encode(message.groupChats, writer.uint32(18).fork()).join();
    }
    if (message.groupChat !== undefined) {
      GroupChat.encode(message.groupChat, writer.uint32(26).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupChannelMessage.encode(message.groupMessage, writer.uint32(34).fork()).join();
    }
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(42).fork()).join();
    }
    if (message.userChats !== undefined) {
      UserMessages.encode(message.userChats, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = Response.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupChats = GroupChats.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.groupChat = GroupChat.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessage = GroupChannelMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userChats = UserMessages.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      response: isSet(object.response) ? Response.fromJSON(object.response) : undefined,
      groupChats: isSet(object.groupChats) ? GroupChats.fromJSON(object.groupChats) : undefined,
      groupChat: isSet(object.groupChat) ? GroupChat.fromJSON(object.groupChat) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupChannelMessage.fromJSON(object.groupMessage) : undefined,
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      userChats: isSet(object.userChats) ? UserMessages.fromJSON(object.userChats) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = Response.toJSON(message.response);
    }
    if (message.groupChats !== undefined) {
      obj.groupChats = GroupChats.toJSON(message.groupChats);
    }
    if (message.groupChat !== undefined) {
      obj.groupChat = GroupChat.toJSON(message.groupChat);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupChannelMessage.toJSON(message.groupMessage);
    }
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.userChats !== undefined) {
      obj.userChats = UserMessages.toJSON(message.userChats);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.response = (object.response !== undefined && object.response !== null)
      ? Response.fromPartial(object.response)
      : undefined;
    message.groupChats = (object.groupChats !== undefined && object.groupChats !== null)
      ? GroupChats.fromPartial(object.groupChats)
      : undefined;
    message.groupChat = (object.groupChat !== undefined && object.groupChat !== null)
      ? GroupChat.fromPartial(object.groupChat)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupChannelMessage.fromPartial(object.groupMessage)
      : undefined;
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.userChats = (object.userChats !== undefined && object.userChats !== null)
      ? UserMessages.fromPartial(object.userChats)
      : undefined;
    return message;
  },
};

function createBaseUserMessage(): UserMessage {
  return { id: new Uint8Array(0), version: 0, text: "", to: "", from: "" };
}

export const UserMessage: MessageFns<UserMessage> = {
  encode(message: UserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id.length !== 0) {
      writer.uint32(10).bytes(message.id);
    }
    if (message.version !== 0) {
      writer.uint32(16).int32(message.version);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.to !== "") {
      writer.uint32(34).string(message.to);
    }
    if (message.from !== "") {
      writer.uint32(42).string(message.from);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.from = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessage {
    return {
      id: isSet(object.id) ? bytesFromBase64(object.id) : new Uint8Array(0),
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      from: isSet(object.from) ? globalThis.String(object.from) : "",
    };
  },

  toJSON(message: UserMessage): unknown {
    const obj: any = {};
    if (message.id.length !== 0) {
      obj.id = base64FromBytes(message.id);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.from !== "") {
      obj.from = message.from;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessage>, I>>(base?: I): UserMessage {
    return UserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessage>, I>>(object: I): UserMessage {
    const message = createBaseUserMessage();
    message.id = object.id ?? new Uint8Array(0);
    message.version = object.version ?? 0;
    message.text = object.text ?? "";
    message.to = object.to ?? "";
    message.from = object.from ?? "";
    return message;
  },
};

function createBaseUserMessages(): UserMessages {
  return { messages: [] };
}

export const UserMessages: MessageFns<UserMessages> = {
  encode(message: UserMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      UserMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(UserMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => UserMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => UserMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessages>, I>>(base?: I): UserMessages {
    return UserMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessages>, I>>(object: I): UserMessages {
    const message = createBaseUserMessages();
    message.messages = object.messages?.map((e) => UserMessage.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
