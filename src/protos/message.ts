// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.1
// source: message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "firefly";

export enum CallMessageType {
  none = 0,
  request = 1,
  reject = 2,
  end = 3,
  /** ended - for saving call messages */
  ended = 4,
  rejected = 5,
  /** candidate - webrtc messages */
  candidate = 10,
  answer = 11,
  offer = 12,
  UNRECOGNIZED = -1,
}

export function callMessageTypeFromJSON(object: any): CallMessageType {
  switch (object) {
    case 0:
    case "none":
      return CallMessageType.none;
    case 1:
    case "request":
      return CallMessageType.request;
    case 2:
    case "reject":
      return CallMessageType.reject;
    case 3:
    case "end":
      return CallMessageType.end;
    case 4:
    case "ended":
      return CallMessageType.ended;
    case 5:
    case "rejected":
      return CallMessageType.rejected;
    case 10:
    case "candidate":
      return CallMessageType.candidate;
    case 11:
    case "answer":
      return CallMessageType.answer;
    case 12:
    case "offer":
      return CallMessageType.offer;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CallMessageType.UNRECOGNIZED;
  }
}

export function callMessageTypeToJSON(object: CallMessageType): string {
  switch (object) {
    case CallMessageType.none:
      return "none";
    case CallMessageType.request:
      return "request";
    case CallMessageType.reject:
      return "reject";
    case CallMessageType.end:
      return "end";
    case CallMessageType.ended:
      return "ended";
    case CallMessageType.rejected:
      return "rejected";
    case CallMessageType.candidate:
      return "candidate";
    case CallMessageType.answer:
      return "answer";
    case CallMessageType.offer:
      return "offer";
    case CallMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface UserMessage {
  id: bigint;
  toId: bigint;
  fromId: bigint;
  text: Uint8Array;
  type: number;
  /** flags for server to notify or just send or don't send */
  settings: number;
  /** optional sends these for decryption purposes */
  fromUsername: string;
  fromDeviceId: number;
}

export interface Group {
  id: bigint;
  name: string;
  description: string;
  pfp: boolean;
  state: Uint8Array;
}

export interface Groups {
  groups: Group[];
}

export interface UserMessages {
  messages: UserMessage[];
}

export interface GroupInvite {
  groupId: bigint;
  inviter: string;
  invitee: string;
  welcomeMessage: Uint8Array;
  commitId: bigint;
}

export interface GroupCommitAndWelcome {
  id: bigint;
  groupId: bigint;
  commitMessage: Uint8Array;
  inviter: string;
  invitee: string;
  welcomeMessage: Uint8Array;
  inviteeAddresses: bigint[];
}

export interface GroupInvites {
  invites: GroupInvite[];
}

export interface GroupMessage {
  id: bigint;
  groupId: bigint;
  message: Uint8Array;
}

export interface GroupKeyPackage {
  id: number;
  package: Uint8Array;
  address: bigint;
  username: string;
}

export interface GroupKeyPackages {
  packages: GroupKeyPackage[];
}

export interface GroupMessages {
  messages: GroupMessage[];
}

export interface GroupSyncRequest {
  groupId: bigint;
  startAfter: bigint;
  until: bigint;
  limit: number;
}

export interface GroupSyncRequests {
  requests: GroupSyncRequest[];
}

export interface GroupReAddRequest {
  groupId: bigint;
  addressId: bigint;
  username: string;
}

export interface GroupReAddRequests {
  requests: GroupReAddRequest[];
}

export interface Error {
  errorCode: number;
  error: string;
}

export interface Result {
  resultCode: number;
  body: Uint8Array;
}

export interface Address {
  id: bigint;
  username: string;
  deviceId: number;
  fcmToken: string;
}

export interface Addresses {
  addresses: Address[];
}

export interface UploadUserMessage {
  messages: UserMessage[];
}

export interface MessageIdAndTo {
  id: bigint;
  to: bigint;
  isSelf: boolean;
}

export interface UserMessageUploaded {
  messageIds: MessageIdAndTo[];
}

export interface Request {
  id: number;
  createUserMessage?: UserMessage | undefined;
  uploadUserMessage?: UploadUserMessage | undefined;
  uploadGroupMessage?: GroupMessage | undefined;
}

export interface Response {
  id: number;
  error: Error | undefined;
  createdUserMessage?: UserMessage | undefined;
  userMessageUploaded?: UserMessageUploaded | undefined;
  groupMessageUploaded?: GroupMessage | undefined;
}

export interface ServerMessage {
  userMessage?: UserMessage | undefined;
  groupMessage?: GroupMessage | undefined;
  userMessages?: UserMessages | undefined;
  groupMessages?: GroupMessages | undefined;
  response?: Response | undefined;
  ping?: Uint8Array | undefined;
  pong?: Uint8Array | undefined;
}

export interface SubscribeGroup {
  id: bigint;
}

export interface UnSubscribeGroup {
  id: bigint;
}

export interface ClientMessage {
  userMessage?: UserMessage | undefined;
  groupMessage?: GroupMessage | undefined;
  userMessages?: UserMessages | undefined;
  groupMessages?: GroupMessages | undefined;
  bearerToken?: string | undefined;
  subscribeGroup?: SubscribeGroup | undefined;
  unSubscribeGroup?: UnSubscribeGroup | undefined;
  request?: Request | undefined;
  ping?: Uint8Array | undefined;
  pong?: Uint8Array | undefined;
}

export interface GroupId {
  id: bigint;
}

export interface AuthToken {
  username: string;
  validUntil: bigint;
  issuer: string;
  credential: Uint8Array;
  deviceId: number;
  addressId: bigint;
}

export interface SignedToken {
  kid: string;
  payload: Uint8Array;
  signature: Uint8Array;
}

export interface FireflyIdentity {
  secret: Uint8Array;
  public: Uint8Array;
  credential: Uint8Array;
}

export interface FireflyGroupExtension {
  name: string;
  roles: FireflyGroupRoles | undefined;
  channels: FireflyGroupChannels | undefined;
  members: FireflyGroupMembers | undefined;
}

export interface FireflyGroupRole {
  id: number;
  name: string;
  permissions: number;
}

export interface FireflyGroupRoles {
  roles: FireflyGroupRole[];
}

export interface FireflyGroupMember {
  username: string;
  role: number;
}

export interface FireflyGroupMembers {
  members: FireflyGroupMember[];
}

export interface FireflyGroupChannel {
  id: number;
  name: string;
  type: number;
  roles: FireflyGroupRoles | undefined;
}

export interface FireflyGroupChannels {
  channels: FireflyGroupChannel[];
}

export interface PreKeyBundle {
  registrationId: number;
  deviceId: number;
  preKeyId: number;
  prePublicKey: Uint8Array;
  signedPreKeyId: number;
  signedPrePublicKey: Uint8Array;
  signedPreKeySignature: Uint8Array;
  identityPublicKey: Uint8Array;
  KEMPreKeyId: number;
  KEMPrePublicKey: Uint8Array;
  KEMPreKeySignature: Uint8Array;
}

export interface PreKeyBundleEntry {
  id: number;
  address: bigint;
  bundle: PreKeyBundle | undefined;
  username: string;
  deviceId: number;
}

export interface PreKeyBundleEntries {
  entries: PreKeyBundleEntry[];
}

export interface ConversationStart {
  conversationId: bigint;
  startedBy: string;
  other: string;
  bundle: PreKeyBundle | undefined;
}

export interface PreKeyBundles {
  bundles: PreKeyBundle[];
}

export interface Conversation {
  user1: string;
  user2: string;
  settings: bigint;
}

export interface Conversations {
  conversations: Conversation[];
}

export interface EncryptedFile {
  url: string;
  contentType: number;
  secretKey: Uint8Array;
  contentLength: number;
}

export interface EncryptedFiles {
  files: EncryptedFile[];
}

export interface MessagePayload {
  text: string;
  replyingTo: bigint;
  files: EncryptedFiles | undefined;
}

export interface CallMessage {
  message: Uint8Array;
  sessionId: number;
  type: CallMessageType;
  jsonBody: string;
}

export interface SelfUserMessage {
  to: string;
  /** UserMessageInner encrypted */
  inner: Uint8Array;
}

export interface UserMessageInner {
  plainText?: Uint8Array | undefined;
  callMessage?: CallMessage | undefined;
  messagePayload?: MessagePayload | undefined;
  selfMessage?: SelfUserMessage | undefined;
}

export interface GroupMessageInner {
  channelId: number;
  messagePayload?: MessagePayload | undefined;
}

function createBaseUserMessage(): UserMessage {
  return {
    id: 0n,
    toId: 0n,
    fromId: 0n,
    text: new Uint8Array(0),
    type: 0,
    settings: 0,
    fromUsername: "",
    fromDeviceId: 0,
  };
}

export const UserMessage: MessageFns<UserMessage> = {
  encode(message: UserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.toId !== 0n) {
      if (BigInt.asUintN(64, message.toId) !== message.toId) {
        throw new globalThis.Error("value provided for field message.toId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.toId);
    }
    if (message.fromId !== 0n) {
      if (BigInt.asUintN(64, message.fromId) !== message.fromId) {
        throw new globalThis.Error("value provided for field message.fromId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.fromId);
    }
    if (message.text.length !== 0) {
      writer.uint32(34).bytes(message.text);
    }
    if (message.type !== 0) {
      writer.uint32(48).uint32(message.type);
    }
    if (message.settings !== 0) {
      writer.uint32(56).uint32(message.settings);
    }
    if (message.fromUsername !== "") {
      writer.uint32(66).string(message.fromUsername);
    }
    if (message.fromDeviceId !== 0) {
      writer.uint32(72).uint32(message.fromDeviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fromId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.settings = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fromUsername = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.fromDeviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessage {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      toId: isSet(object.toId) ? BigInt(object.toId) : 0n,
      fromId: isSet(object.fromId) ? BigInt(object.fromId) : 0n,
      text: isSet(object.text) ? bytesFromBase64(object.text) : new Uint8Array(0),
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      settings: isSet(object.settings) ? globalThis.Number(object.settings) : 0,
      fromUsername: isSet(object.fromUsername) ? globalThis.String(object.fromUsername) : "",
      fromDeviceId: isSet(object.fromDeviceId) ? globalThis.Number(object.fromDeviceId) : 0,
    };
  },

  toJSON(message: UserMessage): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.toId !== 0n) {
      obj.toId = message.toId.toString();
    }
    if (message.fromId !== 0n) {
      obj.fromId = message.fromId.toString();
    }
    if (message.text.length !== 0) {
      obj.text = base64FromBytes(message.text);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.settings !== 0) {
      obj.settings = Math.round(message.settings);
    }
    if (message.fromUsername !== "") {
      obj.fromUsername = message.fromUsername;
    }
    if (message.fromDeviceId !== 0) {
      obj.fromDeviceId = Math.round(message.fromDeviceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessage>, I>>(base?: I): UserMessage {
    return UserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessage>, I>>(object: I): UserMessage {
    const message = createBaseUserMessage();
    message.id = object.id ?? 0n;
    message.toId = object.toId ?? 0n;
    message.fromId = object.fromId ?? 0n;
    message.text = object.text ?? new Uint8Array(0);
    message.type = object.type ?? 0;
    message.settings = object.settings ?? 0;
    message.fromUsername = object.fromUsername ?? "";
    message.fromDeviceId = object.fromDeviceId ?? 0;
    return message;
  },
};

function createBaseGroup(): Group {
  return { id: 0n, name: "", description: "", pfp: false, state: new Uint8Array(0) };
}

export const Group: MessageFns<Group> = {
  encode(message: Group, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.pfp !== false) {
      writer.uint32(32).bool(message.pfp);
    }
    if (message.state.length !== 0) {
      writer.uint32(42).bytes(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Group {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pfp = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.state = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Group {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pfp: isSet(object.pfp) ? globalThis.Boolean(object.pfp) : false,
      state: isSet(object.state) ? bytesFromBase64(object.state) : new Uint8Array(0),
    };
  },

  toJSON(message: Group): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pfp !== false) {
      obj.pfp = message.pfp;
    }
    if (message.state.length !== 0) {
      obj.state = base64FromBytes(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Group>, I>>(base?: I): Group {
    return Group.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Group>, I>>(object: I): Group {
    const message = createBaseGroup();
    message.id = object.id ?? 0n;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.pfp = object.pfp ?? false;
    message.state = object.state ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroups(): Groups {
  return { groups: [] };
}

export const Groups: MessageFns<Groups> = {
  encode(message: Groups, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Groups {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroups();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groups.push(Group.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Groups {
    return { groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e: any) => Group.fromJSON(e)) : [] };
  },

  toJSON(message: Groups): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => Group.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Groups>, I>>(base?: I): Groups {
    return Groups.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Groups>, I>>(object: I): Groups {
    const message = createBaseGroups();
    message.groups = object.groups?.map((e) => Group.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserMessages(): UserMessages {
  return { messages: [] };
}

export const UserMessages: MessageFns<UserMessages> = {
  encode(message: UserMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      UserMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(UserMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => UserMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => UserMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessages>, I>>(base?: I): UserMessages {
    return UserMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessages>, I>>(object: I): UserMessages {
    const message = createBaseUserMessages();
    message.messages = object.messages?.map((e) => UserMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupInvite(): GroupInvite {
  return { groupId: 0n, inviter: "", invitee: "", welcomeMessage: new Uint8Array(0), commitId: 0n };
}

export const GroupInvite: MessageFns<GroupInvite> = {
  encode(message: GroupInvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.groupId);
    }
    if (message.inviter !== "") {
      writer.uint32(18).string(message.inviter);
    }
    if (message.invitee !== "") {
      writer.uint32(26).string(message.invitee);
    }
    if (message.welcomeMessage.length !== 0) {
      writer.uint32(34).bytes(message.welcomeMessage);
    }
    if (message.commitId !== 0n) {
      if (BigInt.asUintN(64, message.commitId) !== message.commitId) {
        throw new globalThis.Error("value provided for field message.commitId of type uint64 too large");
      }
      writer.uint32(40).uint64(message.commitId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inviter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.invitee = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.welcomeMessage = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.commitId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInvite {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      inviter: isSet(object.inviter) ? globalThis.String(object.inviter) : "",
      invitee: isSet(object.invitee) ? globalThis.String(object.invitee) : "",
      welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array(0),
      commitId: isSet(object.commitId) ? BigInt(object.commitId) : 0n,
    };
  },

  toJSON(message: GroupInvite): unknown {
    const obj: any = {};
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.inviter !== "") {
      obj.inviter = message.inviter;
    }
    if (message.invitee !== "") {
      obj.invitee = message.invitee;
    }
    if (message.welcomeMessage.length !== 0) {
      obj.welcomeMessage = base64FromBytes(message.welcomeMessage);
    }
    if (message.commitId !== 0n) {
      obj.commitId = message.commitId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInvite>, I>>(base?: I): GroupInvite {
    return GroupInvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInvite>, I>>(object: I): GroupInvite {
    const message = createBaseGroupInvite();
    message.groupId = object.groupId ?? 0n;
    message.inviter = object.inviter ?? "";
    message.invitee = object.invitee ?? "";
    message.welcomeMessage = object.welcomeMessage ?? new Uint8Array(0);
    message.commitId = object.commitId ?? 0n;
    return message;
  },
};

function createBaseGroupCommitAndWelcome(): GroupCommitAndWelcome {
  return {
    id: 0n,
    groupId: 0n,
    commitMessage: new Uint8Array(0),
    inviter: "",
    invitee: "",
    welcomeMessage: new Uint8Array(0),
    inviteeAddresses: [],
  };
}

export const GroupCommitAndWelcome: MessageFns<GroupCommitAndWelcome> = {
  encode(message: GroupCommitAndWelcome, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.groupId);
    }
    if (message.commitMessage.length !== 0) {
      writer.uint32(26).bytes(message.commitMessage);
    }
    if (message.inviter !== "") {
      writer.uint32(34).string(message.inviter);
    }
    if (message.invitee !== "") {
      writer.uint32(42).string(message.invitee);
    }
    if (message.welcomeMessage.length !== 0) {
      writer.uint32(50).bytes(message.welcomeMessage);
    }
    writer.uint32(58).fork();
    for (const v of message.inviteeAddresses) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field inviteeAddresses of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupCommitAndWelcome {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupCommitAndWelcome();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commitMessage = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inviter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.invitee = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.welcomeMessage = reader.bytes();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.inviteeAddresses.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inviteeAddresses.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupCommitAndWelcome {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      commitMessage: isSet(object.commitMessage) ? bytesFromBase64(object.commitMessage) : new Uint8Array(0),
      inviter: isSet(object.inviter) ? globalThis.String(object.inviter) : "",
      invitee: isSet(object.invitee) ? globalThis.String(object.invitee) : "",
      welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array(0),
      inviteeAddresses: globalThis.Array.isArray(object?.inviteeAddresses)
        ? object.inviteeAddresses.map((e: any) => BigInt(e))
        : [],
    };
  },

  toJSON(message: GroupCommitAndWelcome): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.commitMessage.length !== 0) {
      obj.commitMessage = base64FromBytes(message.commitMessage);
    }
    if (message.inviter !== "") {
      obj.inviter = message.inviter;
    }
    if (message.invitee !== "") {
      obj.invitee = message.invitee;
    }
    if (message.welcomeMessage.length !== 0) {
      obj.welcomeMessage = base64FromBytes(message.welcomeMessage);
    }
    if (message.inviteeAddresses?.length) {
      obj.inviteeAddresses = message.inviteeAddresses.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupCommitAndWelcome>, I>>(base?: I): GroupCommitAndWelcome {
    return GroupCommitAndWelcome.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupCommitAndWelcome>, I>>(object: I): GroupCommitAndWelcome {
    const message = createBaseGroupCommitAndWelcome();
    message.id = object.id ?? 0n;
    message.groupId = object.groupId ?? 0n;
    message.commitMessage = object.commitMessage ?? new Uint8Array(0);
    message.inviter = object.inviter ?? "";
    message.invitee = object.invitee ?? "";
    message.welcomeMessage = object.welcomeMessage ?? new Uint8Array(0);
    message.inviteeAddresses = object.inviteeAddresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseGroupInvites(): GroupInvites {
  return { invites: [] };
}

export const GroupInvites: MessageFns<GroupInvites> = {
  encode(message: GroupInvites, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.invites) {
      GroupInvite.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupInvites {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupInvites();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.invites.push(GroupInvite.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupInvites {
    return {
      invites: globalThis.Array.isArray(object?.invites) ? object.invites.map((e: any) => GroupInvite.fromJSON(e)) : [],
    };
  },

  toJSON(message: GroupInvites): unknown {
    const obj: any = {};
    if (message.invites?.length) {
      obj.invites = message.invites.map((e) => GroupInvite.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupInvites>, I>>(base?: I): GroupInvites {
    return GroupInvites.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupInvites>, I>>(object: I): GroupInvites {
    const message = createBaseGroupInvites();
    message.invites = object.invites?.map((e) => GroupInvite.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupMessage(): GroupMessage {
  return { id: 0n, groupId: 0n, message: new Uint8Array(0) };
}

export const GroupMessage: MessageFns<GroupMessage> = {
  encode(message: GroupMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.groupId);
    }
    if (message.message.length !== 0) {
      writer.uint32(26).bytes(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMessage {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
    };
  },

  toJSON(message: GroupMessage): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMessage>, I>>(base?: I): GroupMessage {
    return GroupMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMessage>, I>>(object: I): GroupMessage {
    const message = createBaseGroupMessage();
    message.id = object.id ?? 0n;
    message.groupId = object.groupId ?? 0n;
    message.message = object.message ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGroupKeyPackage(): GroupKeyPackage {
  return { id: 0, package: new Uint8Array(0), address: 0n, username: "" };
}

export const GroupKeyPackage: MessageFns<GroupKeyPackage> = {
  encode(message: GroupKeyPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.package.length !== 0) {
      writer.uint32(18).bytes(message.package);
    }
    if (message.address !== 0n) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(24).uint64(message.address);
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupKeyPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupKeyPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.package = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupKeyPackage {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      package: isSet(object.package) ? bytesFromBase64(object.package) : new Uint8Array(0),
      address: isSet(object.address) ? BigInt(object.address) : 0n,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: GroupKeyPackage): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.package.length !== 0) {
      obj.package = base64FromBytes(message.package);
    }
    if (message.address !== 0n) {
      obj.address = message.address.toString();
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupKeyPackage>, I>>(base?: I): GroupKeyPackage {
    return GroupKeyPackage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupKeyPackage>, I>>(object: I): GroupKeyPackage {
    const message = createBaseGroupKeyPackage();
    message.id = object.id ?? 0;
    message.package = object.package ?? new Uint8Array(0);
    message.address = object.address ?? 0n;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGroupKeyPackages(): GroupKeyPackages {
  return { packages: [] };
}

export const GroupKeyPackages: MessageFns<GroupKeyPackages> = {
  encode(message: GroupKeyPackages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packages) {
      GroupKeyPackage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupKeyPackages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupKeyPackages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.packages.push(GroupKeyPackage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupKeyPackages {
    return {
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => GroupKeyPackage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupKeyPackages): unknown {
    const obj: any = {};
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => GroupKeyPackage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupKeyPackages>, I>>(base?: I): GroupKeyPackages {
    return GroupKeyPackages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupKeyPackages>, I>>(object: I): GroupKeyPackages {
    const message = createBaseGroupKeyPackages();
    message.packages = object.packages?.map((e) => GroupKeyPackage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupMessages(): GroupMessages {
  return { messages: [] };
}

export const GroupMessages: MessageFns<GroupMessages> = {
  encode(message: GroupMessages, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      GroupMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMessages {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMessages();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messages.push(GroupMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMessages {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => GroupMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupMessages): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => GroupMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMessages>, I>>(base?: I): GroupMessages {
    return GroupMessages.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMessages>, I>>(object: I): GroupMessages {
    const message = createBaseGroupMessages();
    message.messages = object.messages?.map((e) => GroupMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupSyncRequest(): GroupSyncRequest {
  return { groupId: 0n, startAfter: 0n, until: 0n, limit: 0 };
}

export const GroupSyncRequest: MessageFns<GroupSyncRequest> = {
  encode(message: GroupSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.groupId);
    }
    if (message.startAfter !== 0n) {
      if (BigInt.asUintN(64, message.startAfter) !== message.startAfter) {
        throw new globalThis.Error("value provided for field message.startAfter of type uint64 too large");
      }
      writer.uint32(16).uint64(message.startAfter);
    }
    if (message.until !== 0n) {
      if (BigInt.asUintN(64, message.until) !== message.until) {
        throw new globalThis.Error("value provided for field message.until of type uint64 too large");
      }
      writer.uint32(24).uint64(message.until);
    }
    if (message.limit !== 0) {
      writer.uint32(32).uint32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupSyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startAfter = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.until = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupSyncRequest {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      startAfter: isSet(object.startAfter) ? BigInt(object.startAfter) : 0n,
      until: isSet(object.until) ? BigInt(object.until) : 0n,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: GroupSyncRequest): unknown {
    const obj: any = {};
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.startAfter !== 0n) {
      obj.startAfter = message.startAfter.toString();
    }
    if (message.until !== 0n) {
      obj.until = message.until.toString();
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupSyncRequest>, I>>(base?: I): GroupSyncRequest {
    return GroupSyncRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupSyncRequest>, I>>(object: I): GroupSyncRequest {
    const message = createBaseGroupSyncRequest();
    message.groupId = object.groupId ?? 0n;
    message.startAfter = object.startAfter ?? 0n;
    message.until = object.until ?? 0n;
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseGroupSyncRequests(): GroupSyncRequests {
  return { requests: [] };
}

export const GroupSyncRequests: MessageFns<GroupSyncRequests> = {
  encode(message: GroupSyncRequests, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      GroupSyncRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupSyncRequests {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupSyncRequests();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(GroupSyncRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupSyncRequests {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => GroupSyncRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupSyncRequests): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => GroupSyncRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupSyncRequests>, I>>(base?: I): GroupSyncRequests {
    return GroupSyncRequests.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupSyncRequests>, I>>(object: I): GroupSyncRequests {
    const message = createBaseGroupSyncRequests();
    message.requests = object.requests?.map((e) => GroupSyncRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGroupReAddRequest(): GroupReAddRequest {
  return { groupId: 0n, addressId: 0n, username: "" };
}

export const GroupReAddRequest: MessageFns<GroupReAddRequest> = {
  encode(message: GroupReAddRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.groupId !== 0n) {
      if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
        throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.groupId);
    }
    if (message.addressId !== 0n) {
      if (BigInt.asUintN(64, message.addressId) !== message.addressId) {
        throw new globalThis.Error("value provided for field message.addressId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.addressId);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupReAddRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupReAddRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.groupId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.addressId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupReAddRequest {
    return {
      groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
      addressId: isSet(object.addressId) ? BigInt(object.addressId) : 0n,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: GroupReAddRequest): unknown {
    const obj: any = {};
    if (message.groupId !== 0n) {
      obj.groupId = message.groupId.toString();
    }
    if (message.addressId !== 0n) {
      obj.addressId = message.addressId.toString();
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupReAddRequest>, I>>(base?: I): GroupReAddRequest {
    return GroupReAddRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupReAddRequest>, I>>(object: I): GroupReAddRequest {
    const message = createBaseGroupReAddRequest();
    message.groupId = object.groupId ?? 0n;
    message.addressId = object.addressId ?? 0n;
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGroupReAddRequests(): GroupReAddRequests {
  return { requests: [] };
}

export const GroupReAddRequests: MessageFns<GroupReAddRequests> = {
  encode(message: GroupReAddRequests, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      GroupReAddRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupReAddRequests {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupReAddRequests();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requests.push(GroupReAddRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupReAddRequests {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => GroupReAddRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GroupReAddRequests): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => GroupReAddRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupReAddRequests>, I>>(base?: I): GroupReAddRequests {
    return GroupReAddRequests.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupReAddRequests>, I>>(object: I): GroupReAddRequests {
    const message = createBaseGroupReAddRequests();
    message.requests = object.requests?.map((e) => GroupReAddRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseError(): Error {
  return { errorCode: 0, error: "" };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== 0) {
      writer.uint32(8).uint32(message.errorCode);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.errorCode = object.errorCode ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseResult(): Result {
  return { resultCode: 0, body: new Uint8Array(0) };
}

export const Result: MessageFns<Result> = {
  encode(message: Result, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resultCode !== 0) {
      writer.uint32(8).uint32(message.resultCode);
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Result {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.resultCode = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Result {
    return {
      resultCode: isSet(object.resultCode) ? globalThis.Number(object.resultCode) : 0,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
    };
  },

  toJSON(message: Result): unknown {
    const obj: any = {};
    if (message.resultCode !== 0) {
      obj.resultCode = Math.round(message.resultCode);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Result>, I>>(base?: I): Result {
    return Result.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Result>, I>>(object: I): Result {
    const message = createBaseResult();
    message.resultCode = object.resultCode ?? 0;
    message.body = object.body ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAddress(): Address {
  return { id: 0n, username: "", deviceId: 0, fcmToken: "" };
}

export const Address: MessageFns<Address> = {
  encode(message: Address, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.deviceId !== 0) {
      writer.uint32(24).uint32(message.deviceId);
    }
    if (message.fcmToken !== "") {
      writer.uint32(34).string(message.fcmToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Address {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.deviceId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fcmToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Address {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
      fcmToken: isSet(object.fcmToken) ? globalThis.String(object.fcmToken) : "",
    };
  },

  toJSON(message: Address): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.deviceId !== 0) {
      obj.deviceId = Math.round(message.deviceId);
    }
    if (message.fcmToken !== "") {
      obj.fcmToken = message.fcmToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Address>, I>>(base?: I): Address {
    return Address.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Address>, I>>(object: I): Address {
    const message = createBaseAddress();
    message.id = object.id ?? 0n;
    message.username = object.username ?? "";
    message.deviceId = object.deviceId ?? 0;
    message.fcmToken = object.fcmToken ?? "";
    return message;
  },
};

function createBaseAddresses(): Addresses {
  return { addresses: [] };
}

export const Addresses: MessageFns<Addresses> = {
  encode(message: Addresses, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Addresses {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddresses();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Addresses {
    return {
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => Address.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Addresses): unknown {
    const obj: any = {};
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => Address.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Addresses>, I>>(base?: I): Addresses {
    return Addresses.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Addresses>, I>>(object: I): Addresses {
    const message = createBaseAddresses();
    message.addresses = object.addresses?.map((e) => Address.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadUserMessage(): UploadUserMessage {
  return { messages: [] };
}

export const UploadUserMessage: MessageFns<UploadUserMessage> = {
  encode(message: UploadUserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      UserMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadUserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(UserMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadUserMessage {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => UserMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UploadUserMessage): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => UserMessage.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadUserMessage>, I>>(base?: I): UploadUserMessage {
    return UploadUserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadUserMessage>, I>>(object: I): UploadUserMessage {
    const message = createBaseUploadUserMessage();
    message.messages = object.messages?.map((e) => UserMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageIdAndTo(): MessageIdAndTo {
  return { id: 0n, to: 0n, isSelf: false };
}

export const MessageIdAndTo: MessageFns<MessageIdAndTo> = {
  encode(message: MessageIdAndTo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    if (message.to !== 0n) {
      if (BigInt.asUintN(64, message.to) !== message.to) {
        throw new globalThis.Error("value provided for field message.to of type uint64 too large");
      }
      writer.uint32(16).uint64(message.to);
    }
    if (message.isSelf !== false) {
      writer.uint32(24).bool(message.isSelf);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageIdAndTo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageIdAndTo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.to = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isSelf = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageIdAndTo {
    return {
      id: isSet(object.id) ? BigInt(object.id) : 0n,
      to: isSet(object.to) ? BigInt(object.to) : 0n,
      isSelf: isSet(object.isSelf) ? globalThis.Boolean(object.isSelf) : false,
    };
  },

  toJSON(message: MessageIdAndTo): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    if (message.to !== 0n) {
      obj.to = message.to.toString();
    }
    if (message.isSelf !== false) {
      obj.isSelf = message.isSelf;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageIdAndTo>, I>>(base?: I): MessageIdAndTo {
    return MessageIdAndTo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageIdAndTo>, I>>(object: I): MessageIdAndTo {
    const message = createBaseMessageIdAndTo();
    message.id = object.id ?? 0n;
    message.to = object.to ?? 0n;
    message.isSelf = object.isSelf ?? false;
    return message;
  },
};

function createBaseUserMessageUploaded(): UserMessageUploaded {
  return { messageIds: [] };
}

export const UserMessageUploaded: MessageFns<UserMessageUploaded> = {
  encode(message: UserMessageUploaded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messageIds) {
      MessageIdAndTo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessageUploaded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessageUploaded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageIds.push(MessageIdAndTo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessageUploaded {
    return {
      messageIds: globalThis.Array.isArray(object?.messageIds)
        ? object.messageIds.map((e: any) => MessageIdAndTo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserMessageUploaded): unknown {
    const obj: any = {};
    if (message.messageIds?.length) {
      obj.messageIds = message.messageIds.map((e) => MessageIdAndTo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessageUploaded>, I>>(base?: I): UserMessageUploaded {
    return UserMessageUploaded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessageUploaded>, I>>(object: I): UserMessageUploaded {
    const message = createBaseUserMessageUploaded();
    message.messageIds = object.messageIds?.map((e) => MessageIdAndTo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRequest(): Request {
  return { id: 0, createUserMessage: undefined, uploadUserMessage: undefined, uploadGroupMessage: undefined };
}

export const Request: MessageFns<Request> = {
  encode(message: Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.createUserMessage !== undefined) {
      UserMessage.encode(message.createUserMessage, writer.uint32(18).fork()).join();
    }
    if (message.uploadUserMessage !== undefined) {
      UploadUserMessage.encode(message.uploadUserMessage, writer.uint32(26).fork()).join();
    }
    if (message.uploadGroupMessage !== undefined) {
      GroupMessage.encode(message.uploadGroupMessage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createUserMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uploadUserMessage = UploadUserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uploadGroupMessage = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      createUserMessage: isSet(object.createUserMessage) ? UserMessage.fromJSON(object.createUserMessage) : undefined,
      uploadUserMessage: isSet(object.uploadUserMessage)
        ? UploadUserMessage.fromJSON(object.uploadUserMessage)
        : undefined,
      uploadGroupMessage: isSet(object.uploadGroupMessage)
        ? GroupMessage.fromJSON(object.uploadGroupMessage)
        : undefined,
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.createUserMessage !== undefined) {
      obj.createUserMessage = UserMessage.toJSON(message.createUserMessage);
    }
    if (message.uploadUserMessage !== undefined) {
      obj.uploadUserMessage = UploadUserMessage.toJSON(message.uploadUserMessage);
    }
    if (message.uploadGroupMessage !== undefined) {
      obj.uploadGroupMessage = GroupMessage.toJSON(message.uploadGroupMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Request>, I>>(base?: I): Request {
    return Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest();
    message.id = object.id ?? 0;
    message.createUserMessage = (object.createUserMessage !== undefined && object.createUserMessage !== null)
      ? UserMessage.fromPartial(object.createUserMessage)
      : undefined;
    message.uploadUserMessage = (object.uploadUserMessage !== undefined && object.uploadUserMessage !== null)
      ? UploadUserMessage.fromPartial(object.uploadUserMessage)
      : undefined;
    message.uploadGroupMessage = (object.uploadGroupMessage !== undefined && object.uploadGroupMessage !== null)
      ? GroupMessage.fromPartial(object.uploadGroupMessage)
      : undefined;
    return message;
  },
};

function createBaseResponse(): Response {
  return {
    id: 0,
    error: undefined,
    createdUserMessage: undefined,
    userMessageUploaded: undefined,
    groupMessageUploaded: undefined,
  };
}

export const Response: MessageFns<Response> = {
  encode(message: Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join();
    }
    if (message.createdUserMessage !== undefined) {
      UserMessage.encode(message.createdUserMessage, writer.uint32(26).fork()).join();
    }
    if (message.userMessageUploaded !== undefined) {
      UserMessageUploaded.encode(message.userMessageUploaded, writer.uint32(34).fork()).join();
    }
    if (message.groupMessageUploaded !== undefined) {
      GroupMessage.encode(message.groupMessageUploaded, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdUserMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userMessageUploaded = UserMessageUploaded.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.groupMessageUploaded = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Response {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
      createdUserMessage: isSet(object.createdUserMessage)
        ? UserMessage.fromJSON(object.createdUserMessage)
        : undefined,
      userMessageUploaded: isSet(object.userMessageUploaded)
        ? UserMessageUploaded.fromJSON(object.userMessageUploaded)
        : undefined,
      groupMessageUploaded: isSet(object.groupMessageUploaded)
        ? GroupMessage.fromJSON(object.groupMessageUploaded)
        : undefined,
    };
  },

  toJSON(message: Response): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    if (message.createdUserMessage !== undefined) {
      obj.createdUserMessage = UserMessage.toJSON(message.createdUserMessage);
    }
    if (message.userMessageUploaded !== undefined) {
      obj.userMessageUploaded = UserMessageUploaded.toJSON(message.userMessageUploaded);
    }
    if (message.groupMessageUploaded !== undefined) {
      obj.groupMessageUploaded = GroupMessage.toJSON(message.groupMessageUploaded);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse();
    message.id = object.id ?? 0;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    message.createdUserMessage = (object.createdUserMessage !== undefined && object.createdUserMessage !== null)
      ? UserMessage.fromPartial(object.createdUserMessage)
      : undefined;
    message.userMessageUploaded = (object.userMessageUploaded !== undefined && object.userMessageUploaded !== null)
      ? UserMessageUploaded.fromPartial(object.userMessageUploaded)
      : undefined;
    message.groupMessageUploaded = (object.groupMessageUploaded !== undefined && object.groupMessageUploaded !== null)
      ? GroupMessage.fromPartial(object.groupMessageUploaded)
      : undefined;
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return {
    userMessage: undefined,
    groupMessage: undefined,
    userMessages: undefined,
    groupMessages: undefined,
    response: undefined,
    ping: undefined,
    pong: undefined,
  };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
    }
    if (message.userMessages !== undefined) {
      UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
    }
    if (message.groupMessages !== undefined) {
      GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
    }
    if (message.response !== undefined) {
      Response.encode(message.response, writer.uint32(82).fork()).join();
    }
    if (message.ping !== undefined) {
      writer.uint32(90).bytes(message.ping);
    }
    if (message.pong !== undefined) {
      writer.uint32(98).bytes(message.pong);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupMessage = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userMessages = UserMessages.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessages = GroupMessages.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.response = Response.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ping = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pong = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupMessage.fromJSON(object.groupMessage) : undefined,
      userMessages: isSet(object.userMessages) ? UserMessages.fromJSON(object.userMessages) : undefined,
      groupMessages: isSet(object.groupMessages) ? GroupMessages.fromJSON(object.groupMessages) : undefined,
      response: isSet(object.response) ? Response.fromJSON(object.response) : undefined,
      ping: isSet(object.ping) ? bytesFromBase64(object.ping) : undefined,
      pong: isSet(object.pong) ? bytesFromBase64(object.pong) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupMessage.toJSON(message.groupMessage);
    }
    if (message.userMessages !== undefined) {
      obj.userMessages = UserMessages.toJSON(message.userMessages);
    }
    if (message.groupMessages !== undefined) {
      obj.groupMessages = GroupMessages.toJSON(message.groupMessages);
    }
    if (message.response !== undefined) {
      obj.response = Response.toJSON(message.response);
    }
    if (message.ping !== undefined) {
      obj.ping = base64FromBytes(message.ping);
    }
    if (message.pong !== undefined) {
      obj.pong = base64FromBytes(message.pong);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupMessage.fromPartial(object.groupMessage)
      : undefined;
    message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
      ? UserMessages.fromPartial(object.userMessages)
      : undefined;
    message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
      ? GroupMessages.fromPartial(object.groupMessages)
      : undefined;
    message.response = (object.response !== undefined && object.response !== null)
      ? Response.fromPartial(object.response)
      : undefined;
    message.ping = object.ping ?? undefined;
    message.pong = object.pong ?? undefined;
    return message;
  },
};

function createBaseSubscribeGroup(): SubscribeGroup {
  return { id: 0n };
}

export const SubscribeGroup: MessageFns<SubscribeGroup> = {
  encode(message: SubscribeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeGroup {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: SubscribeGroup): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeGroup>, I>>(base?: I): SubscribeGroup {
    return SubscribeGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeGroup>, I>>(object: I): SubscribeGroup {
    const message = createBaseSubscribeGroup();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseUnSubscribeGroup(): UnSubscribeGroup {
  return { id: 0n };
}

export const UnSubscribeGroup: MessageFns<UnSubscribeGroup> = {
  encode(message: UnSubscribeGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnSubscribeGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnSubscribeGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnSubscribeGroup {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: UnSubscribeGroup): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnSubscribeGroup>, I>>(base?: I): UnSubscribeGroup {
    return UnSubscribeGroup.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnSubscribeGroup>, I>>(object: I): UnSubscribeGroup {
    const message = createBaseUnSubscribeGroup();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseClientMessage(): ClientMessage {
  return {
    userMessage: undefined,
    groupMessage: undefined,
    userMessages: undefined,
    groupMessages: undefined,
    bearerToken: undefined,
    subscribeGroup: undefined,
    unSubscribeGroup: undefined,
    request: undefined,
    ping: undefined,
    pong: undefined,
  };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userMessage !== undefined) {
      UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
    }
    if (message.groupMessage !== undefined) {
      GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
    }
    if (message.userMessages !== undefined) {
      UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
    }
    if (message.groupMessages !== undefined) {
      GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
    }
    if (message.bearerToken !== undefined) {
      writer.uint32(42).string(message.bearerToken);
    }
    if (message.subscribeGroup !== undefined) {
      SubscribeGroup.encode(message.subscribeGroup, writer.uint32(50).fork()).join();
    }
    if (message.unSubscribeGroup !== undefined) {
      UnSubscribeGroup.encode(message.unSubscribeGroup, writer.uint32(58).fork()).join();
    }
    if (message.request !== undefined) {
      Request.encode(message.request, writer.uint32(82).fork()).join();
    }
    if (message.ping !== undefined) {
      writer.uint32(90).bytes(message.ping);
    }
    if (message.pong !== undefined) {
      writer.uint32(98).bytes(message.pong);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userMessage = UserMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.groupMessage = GroupMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userMessages = UserMessages.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.groupMessages = GroupMessages.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bearerToken = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscribeGroup = SubscribeGroup.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.unSubscribeGroup = UnSubscribeGroup.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.request = Request.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ping = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pong = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      userMessage: isSet(object.userMessage) ? UserMessage.fromJSON(object.userMessage) : undefined,
      groupMessage: isSet(object.groupMessage) ? GroupMessage.fromJSON(object.groupMessage) : undefined,
      userMessages: isSet(object.userMessages) ? UserMessages.fromJSON(object.userMessages) : undefined,
      groupMessages: isSet(object.groupMessages) ? GroupMessages.fromJSON(object.groupMessages) : undefined,
      bearerToken: isSet(object.bearerToken) ? globalThis.String(object.bearerToken) : undefined,
      subscribeGroup: isSet(object.subscribeGroup) ? SubscribeGroup.fromJSON(object.subscribeGroup) : undefined,
      unSubscribeGroup: isSet(object.unSubscribeGroup) ? UnSubscribeGroup.fromJSON(object.unSubscribeGroup) : undefined,
      request: isSet(object.request) ? Request.fromJSON(object.request) : undefined,
      ping: isSet(object.ping) ? bytesFromBase64(object.ping) : undefined,
      pong: isSet(object.pong) ? bytesFromBase64(object.pong) : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.userMessage !== undefined) {
      obj.userMessage = UserMessage.toJSON(message.userMessage);
    }
    if (message.groupMessage !== undefined) {
      obj.groupMessage = GroupMessage.toJSON(message.groupMessage);
    }
    if (message.userMessages !== undefined) {
      obj.userMessages = UserMessages.toJSON(message.userMessages);
    }
    if (message.groupMessages !== undefined) {
      obj.groupMessages = GroupMessages.toJSON(message.groupMessages);
    }
    if (message.bearerToken !== undefined) {
      obj.bearerToken = message.bearerToken;
    }
    if (message.subscribeGroup !== undefined) {
      obj.subscribeGroup = SubscribeGroup.toJSON(message.subscribeGroup);
    }
    if (message.unSubscribeGroup !== undefined) {
      obj.unSubscribeGroup = UnSubscribeGroup.toJSON(message.unSubscribeGroup);
    }
    if (message.request !== undefined) {
      obj.request = Request.toJSON(message.request);
    }
    if (message.ping !== undefined) {
      obj.ping = base64FromBytes(message.ping);
    }
    if (message.pong !== undefined) {
      obj.pong = base64FromBytes(message.pong);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
      ? UserMessage.fromPartial(object.userMessage)
      : undefined;
    message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
      ? GroupMessage.fromPartial(object.groupMessage)
      : undefined;
    message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
      ? UserMessages.fromPartial(object.userMessages)
      : undefined;
    message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
      ? GroupMessages.fromPartial(object.groupMessages)
      : undefined;
    message.bearerToken = object.bearerToken ?? undefined;
    message.subscribeGroup = (object.subscribeGroup !== undefined && object.subscribeGroup !== null)
      ? SubscribeGroup.fromPartial(object.subscribeGroup)
      : undefined;
    message.unSubscribeGroup = (object.unSubscribeGroup !== undefined && object.unSubscribeGroup !== null)
      ? UnSubscribeGroup.fromPartial(object.unSubscribeGroup)
      : undefined;
    message.request = (object.request !== undefined && object.request !== null)
      ? Request.fromPartial(object.request)
      : undefined;
    message.ping = object.ping ?? undefined;
    message.pong = object.pong ?? undefined;
    return message;
  },
};

function createBaseGroupId(): GroupId {
  return { id: 0n };
}

export const GroupId: MessageFns<GroupId> = {
  encode(message: GroupId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0n) {
      if (BigInt.asUintN(64, message.id) !== message.id) {
        throw new globalThis.Error("value provided for field message.id of type uint64 too large");
      }
      writer.uint32(16).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupId {
    return { id: isSet(object.id) ? BigInt(object.id) : 0n };
  },

  toJSON(message: GroupId): unknown {
    const obj: any = {};
    if (message.id !== 0n) {
      obj.id = message.id.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupId>, I>>(base?: I): GroupId {
    return GroupId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupId>, I>>(object: I): GroupId {
    const message = createBaseGroupId();
    message.id = object.id ?? 0n;
    return message;
  },
};

function createBaseAuthToken(): AuthToken {
  return { username: "", validUntil: 0n, issuer: "", credential: new Uint8Array(0), deviceId: 0, addressId: 0n };
}

export const AuthToken: MessageFns<AuthToken> = {
  encode(message: AuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.validUntil !== 0n) {
      if (BigInt.asUintN(64, message.validUntil) !== message.validUntil) {
        throw new globalThis.Error("value provided for field message.validUntil of type uint64 too large");
      }
      writer.uint32(16).uint64(message.validUntil);
    }
    if (message.issuer !== "") {
      writer.uint32(26).string(message.issuer);
    }
    if (message.credential.length !== 0) {
      writer.uint32(34).bytes(message.credential);
    }
    if (message.deviceId !== 0) {
      writer.uint32(40).uint32(message.deviceId);
    }
    if (message.addressId !== 0n) {
      if (BigInt.asUintN(64, message.addressId) !== message.addressId) {
        throw new globalThis.Error("value provided for field message.addressId of type uint64 too large");
      }
      writer.uint32(48).uint64(message.addressId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.validUntil = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.credential = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deviceId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.addressId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthToken {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      validUntil: isSet(object.validUntil) ? BigInt(object.validUntil) : 0n,
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
      deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
      addressId: isSet(object.addressId) ? BigInt(object.addressId) : 0n,
    };
  },

  toJSON(message: AuthToken): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.validUntil !== 0n) {
      obj.validUntil = message.validUntil.toString();
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.credential.length !== 0) {
      obj.credential = base64FromBytes(message.credential);
    }
    if (message.deviceId !== 0) {
      obj.deviceId = Math.round(message.deviceId);
    }
    if (message.addressId !== 0n) {
      obj.addressId = message.addressId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthToken>, I>>(base?: I): AuthToken {
    return AuthToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthToken>, I>>(object: I): AuthToken {
    const message = createBaseAuthToken();
    message.username = object.username ?? "";
    message.validUntil = object.validUntil ?? 0n;
    message.issuer = object.issuer ?? "";
    message.credential = object.credential ?? new Uint8Array(0);
    message.deviceId = object.deviceId ?? 0;
    message.addressId = object.addressId ?? 0n;
    return message;
  },
};

function createBaseSignedToken(): SignedToken {
  return { kid: "", payload: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const SignedToken: MessageFns<SignedToken> = {
  encode(message: SignedToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kid !== "") {
      writer.uint32(10).string(message.kid);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignedToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignedToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.kid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignedToken {
    return {
      kid: isSet(object.kid) ? globalThis.String(object.kid) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: SignedToken): unknown {
    const obj: any = {};
    if (message.kid !== "") {
      obj.kid = message.kid;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignedToken>, I>>(base?: I): SignedToken {
    return SignedToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignedToken>, I>>(object: I): SignedToken {
    const message = createBaseSignedToken();
    message.kid = object.kid ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFireflyIdentity(): FireflyIdentity {
  return { secret: new Uint8Array(0), public: new Uint8Array(0), credential: new Uint8Array(0) };
}

export const FireflyIdentity: MessageFns<FireflyIdentity> = {
  encode(message: FireflyIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secret.length !== 0) {
      writer.uint32(18).bytes(message.secret);
    }
    if (message.public.length !== 0) {
      writer.uint32(26).bytes(message.public);
    }
    if (message.credential.length !== 0) {
      writer.uint32(34).bytes(message.credential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.secret = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.public = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.credential = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyIdentity {
    return {
      secret: isSet(object.secret) ? bytesFromBase64(object.secret) : new Uint8Array(0),
      public: isSet(object.public) ? bytesFromBase64(object.public) : new Uint8Array(0),
      credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
    };
  },

  toJSON(message: FireflyIdentity): unknown {
    const obj: any = {};
    if (message.secret.length !== 0) {
      obj.secret = base64FromBytes(message.secret);
    }
    if (message.public.length !== 0) {
      obj.public = base64FromBytes(message.public);
    }
    if (message.credential.length !== 0) {
      obj.credential = base64FromBytes(message.credential);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyIdentity>, I>>(base?: I): FireflyIdentity {
    return FireflyIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyIdentity>, I>>(object: I): FireflyIdentity {
    const message = createBaseFireflyIdentity();
    message.secret = object.secret ?? new Uint8Array(0);
    message.public = object.public ?? new Uint8Array(0);
    message.credential = object.credential ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFireflyGroupExtension(): FireflyGroupExtension {
  return { name: "", roles: undefined, channels: undefined, members: undefined };
}

export const FireflyGroupExtension: MessageFns<FireflyGroupExtension> = {
  encode(message: FireflyGroupExtension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.roles !== undefined) {
      FireflyGroupRoles.encode(message.roles, writer.uint32(18).fork()).join();
    }
    if (message.channels !== undefined) {
      FireflyGroupChannels.encode(message.channels, writer.uint32(26).fork()).join();
    }
    if (message.members !== undefined) {
      FireflyGroupMembers.encode(message.members, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupExtension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupExtension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roles = FireflyGroupRoles.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.channels = FireflyGroupChannels.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.members = FireflyGroupMembers.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupExtension {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roles: isSet(object.roles) ? FireflyGroupRoles.fromJSON(object.roles) : undefined,
      channels: isSet(object.channels) ? FireflyGroupChannels.fromJSON(object.channels) : undefined,
      members: isSet(object.members) ? FireflyGroupMembers.fromJSON(object.members) : undefined,
    };
  },

  toJSON(message: FireflyGroupExtension): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roles !== undefined) {
      obj.roles = FireflyGroupRoles.toJSON(message.roles);
    }
    if (message.channels !== undefined) {
      obj.channels = FireflyGroupChannels.toJSON(message.channels);
    }
    if (message.members !== undefined) {
      obj.members = FireflyGroupMembers.toJSON(message.members);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupExtension>, I>>(base?: I): FireflyGroupExtension {
    return FireflyGroupExtension.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupExtension>, I>>(object: I): FireflyGroupExtension {
    const message = createBaseFireflyGroupExtension();
    message.name = object.name ?? "";
    message.roles = (object.roles !== undefined && object.roles !== null)
      ? FireflyGroupRoles.fromPartial(object.roles)
      : undefined;
    message.channels = (object.channels !== undefined && object.channels !== null)
      ? FireflyGroupChannels.fromPartial(object.channels)
      : undefined;
    message.members = (object.members !== undefined && object.members !== null)
      ? FireflyGroupMembers.fromPartial(object.members)
      : undefined;
    return message;
  },
};

function createBaseFireflyGroupRole(): FireflyGroupRole {
  return { id: 0, name: "", permissions: 0 };
}

export const FireflyGroupRole: MessageFns<FireflyGroupRole> = {
  encode(message: FireflyGroupRole, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.permissions !== 0) {
      writer.uint32(24).uint32(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupRole {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permissions = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupRole {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: FireflyGroupRole): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupRole>, I>>(base?: I): FireflyGroupRole {
    return FireflyGroupRole.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupRole>, I>>(object: I): FireflyGroupRole {
    const message = createBaseFireflyGroupRole();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseFireflyGroupRoles(): FireflyGroupRoles {
  return { roles: [] };
}

export const FireflyGroupRoles: MessageFns<FireflyGroupRoles> = {
  encode(message: FireflyGroupRoles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.roles) {
      FireflyGroupRole.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupRoles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupRoles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roles.push(FireflyGroupRole.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupRoles {
    return {
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => FireflyGroupRole.fromJSON(e)) : [],
    };
  },

  toJSON(message: FireflyGroupRoles): unknown {
    const obj: any = {};
    if (message.roles?.length) {
      obj.roles = message.roles.map((e) => FireflyGroupRole.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupRoles>, I>>(base?: I): FireflyGroupRoles {
    return FireflyGroupRoles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupRoles>, I>>(object: I): FireflyGroupRoles {
    const message = createBaseFireflyGroupRoles();
    message.roles = object.roles?.map((e) => FireflyGroupRole.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFireflyGroupMember(): FireflyGroupMember {
  return { username: "", role: 0 };
}

export const FireflyGroupMember: MessageFns<FireflyGroupMember> = {
  encode(message: FireflyGroupMember, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.role !== 0) {
      writer.uint32(16).uint32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupMember {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupMember {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      role: isSet(object.role) ? globalThis.Number(object.role) : 0,
    };
  },

  toJSON(message: FireflyGroupMember): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.role !== 0) {
      obj.role = Math.round(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupMember>, I>>(base?: I): FireflyGroupMember {
    return FireflyGroupMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupMember>, I>>(object: I): FireflyGroupMember {
    const message = createBaseFireflyGroupMember();
    message.username = object.username ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseFireflyGroupMembers(): FireflyGroupMembers {
  return { members: [] };
}

export const FireflyGroupMembers: MessageFns<FireflyGroupMembers> = {
  encode(message: FireflyGroupMembers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.members) {
      FireflyGroupMember.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupMembers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupMembers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.members.push(FireflyGroupMember.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupMembers {
    return {
      members: globalThis.Array.isArray(object?.members)
        ? object.members.map((e: any) => FireflyGroupMember.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FireflyGroupMembers): unknown {
    const obj: any = {};
    if (message.members?.length) {
      obj.members = message.members.map((e) => FireflyGroupMember.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupMembers>, I>>(base?: I): FireflyGroupMembers {
    return FireflyGroupMembers.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupMembers>, I>>(object: I): FireflyGroupMembers {
    const message = createBaseFireflyGroupMembers();
    message.members = object.members?.map((e) => FireflyGroupMember.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFireflyGroupChannel(): FireflyGroupChannel {
  return { id: 0, name: "", type: 0, roles: undefined };
}

export const FireflyGroupChannel: MessageFns<FireflyGroupChannel> = {
  encode(message: FireflyGroupChannel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).uint32(message.type);
    }
    if (message.roles !== undefined) {
      FireflyGroupRoles.encode(message.roles, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupChannel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roles = FireflyGroupRoles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupChannel {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      roles: isSet(object.roles) ? FireflyGroupRoles.fromJSON(object.roles) : undefined,
    };
  },

  toJSON(message: FireflyGroupChannel): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.roles !== undefined) {
      obj.roles = FireflyGroupRoles.toJSON(message.roles);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupChannel>, I>>(base?: I): FireflyGroupChannel {
    return FireflyGroupChannel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupChannel>, I>>(object: I): FireflyGroupChannel {
    const message = createBaseFireflyGroupChannel();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.roles = (object.roles !== undefined && object.roles !== null)
      ? FireflyGroupRoles.fromPartial(object.roles)
      : undefined;
    return message;
  },
};

function createBaseFireflyGroupChannels(): FireflyGroupChannels {
  return { channels: [] };
}

export const FireflyGroupChannels: MessageFns<FireflyGroupChannels> = {
  encode(message: FireflyGroupChannels, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.channels) {
      FireflyGroupChannel.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FireflyGroupChannels {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFireflyGroupChannels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.channels.push(FireflyGroupChannel.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FireflyGroupChannels {
    return {
      channels: globalThis.Array.isArray(object?.channels)
        ? object.channels.map((e: any) => FireflyGroupChannel.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FireflyGroupChannels): unknown {
    const obj: any = {};
    if (message.channels?.length) {
      obj.channels = message.channels.map((e) => FireflyGroupChannel.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FireflyGroupChannels>, I>>(base?: I): FireflyGroupChannels {
    return FireflyGroupChannels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FireflyGroupChannels>, I>>(object: I): FireflyGroupChannels {
    const message = createBaseFireflyGroupChannels();
    message.channels = object.channels?.map((e) => FireflyGroupChannel.fromPartial(e)) || [];
    return message;
  },
};

function createBasePreKeyBundle(): PreKeyBundle {
  return {
    registrationId: 0,
    deviceId: 0,
    preKeyId: 0,
    prePublicKey: new Uint8Array(0),
    signedPreKeyId: 0,
    signedPrePublicKey: new Uint8Array(0),
    signedPreKeySignature: new Uint8Array(0),
    identityPublicKey: new Uint8Array(0),
    KEMPreKeyId: 0,
    KEMPrePublicKey: new Uint8Array(0),
    KEMPreKeySignature: new Uint8Array(0),
  };
}

export const PreKeyBundle: MessageFns<PreKeyBundle> = {
  encode(message: PreKeyBundle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registrationId !== 0) {
      writer.uint32(8).uint32(message.registrationId);
    }
    if (message.deviceId !== 0) {
      writer.uint32(16).uint32(message.deviceId);
    }
    if (message.preKeyId !== 0) {
      writer.uint32(24).uint32(message.preKeyId);
    }
    if (message.prePublicKey.length !== 0) {
      writer.uint32(34).bytes(message.prePublicKey);
    }
    if (message.signedPreKeyId !== 0) {
      writer.uint32(40).uint32(message.signedPreKeyId);
    }
    if (message.signedPrePublicKey.length !== 0) {
      writer.uint32(50).bytes(message.signedPrePublicKey);
    }
    if (message.signedPreKeySignature.length !== 0) {
      writer.uint32(58).bytes(message.signedPreKeySignature);
    }
    if (message.identityPublicKey.length !== 0) {
      writer.uint32(66).bytes(message.identityPublicKey);
    }
    if (message.KEMPreKeyId !== 0) {
      writer.uint32(72).uint32(message.KEMPreKeyId);
    }
    if (message.KEMPrePublicKey.length !== 0) {
      writer.uint32(82).bytes(message.KEMPrePublicKey);
    }
    if (message.KEMPreKeySignature.length !== 0) {
      writer.uint32(90).bytes(message.KEMPreKeySignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.registrationId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.deviceId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.preKeyId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prePublicKey = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.signedPreKeyId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signedPrePublicKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.signedPreKeySignature = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.identityPublicKey = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.KEMPreKeyId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.KEMPrePublicKey = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.KEMPreKeySignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundle {
    return {
      registrationId: isSet(object.registrationId) ? globalThis.Number(object.registrationId) : 0,
      deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
      preKeyId: isSet(object.preKeyId) ? globalThis.Number(object.preKeyId) : 0,
      prePublicKey: isSet(object.prePublicKey) ? bytesFromBase64(object.prePublicKey) : new Uint8Array(0),
      signedPreKeyId: isSet(object.signedPreKeyId) ? globalThis.Number(object.signedPreKeyId) : 0,
      signedPrePublicKey: isSet(object.signedPrePublicKey)
        ? bytesFromBase64(object.signedPrePublicKey)
        : new Uint8Array(0),
      signedPreKeySignature: isSet(object.signedPreKeySignature)
        ? bytesFromBase64(object.signedPreKeySignature)
        : new Uint8Array(0),
      identityPublicKey: isSet(object.identityPublicKey)
        ? bytesFromBase64(object.identityPublicKey)
        : new Uint8Array(0),
      KEMPreKeyId: isSet(object.KEMPreKeyId) ? globalThis.Number(object.KEMPreKeyId) : 0,
      KEMPrePublicKey: isSet(object.KEMPrePublicKey) ? bytesFromBase64(object.KEMPrePublicKey) : new Uint8Array(0),
      KEMPreKeySignature: isSet(object.KEMPreKeySignature)
        ? bytesFromBase64(object.KEMPreKeySignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: PreKeyBundle): unknown {
    const obj: any = {};
    if (message.registrationId !== 0) {
      obj.registrationId = Math.round(message.registrationId);
    }
    if (message.deviceId !== 0) {
      obj.deviceId = Math.round(message.deviceId);
    }
    if (message.preKeyId !== 0) {
      obj.preKeyId = Math.round(message.preKeyId);
    }
    if (message.prePublicKey.length !== 0) {
      obj.prePublicKey = base64FromBytes(message.prePublicKey);
    }
    if (message.signedPreKeyId !== 0) {
      obj.signedPreKeyId = Math.round(message.signedPreKeyId);
    }
    if (message.signedPrePublicKey.length !== 0) {
      obj.signedPrePublicKey = base64FromBytes(message.signedPrePublicKey);
    }
    if (message.signedPreKeySignature.length !== 0) {
      obj.signedPreKeySignature = base64FromBytes(message.signedPreKeySignature);
    }
    if (message.identityPublicKey.length !== 0) {
      obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
    }
    if (message.KEMPreKeyId !== 0) {
      obj.KEMPreKeyId = Math.round(message.KEMPreKeyId);
    }
    if (message.KEMPrePublicKey.length !== 0) {
      obj.KEMPrePublicKey = base64FromBytes(message.KEMPrePublicKey);
    }
    if (message.KEMPreKeySignature.length !== 0) {
      obj.KEMPreKeySignature = base64FromBytes(message.KEMPreKeySignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundle>, I>>(base?: I): PreKeyBundle {
    return PreKeyBundle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundle>, I>>(object: I): PreKeyBundle {
    const message = createBasePreKeyBundle();
    message.registrationId = object.registrationId ?? 0;
    message.deviceId = object.deviceId ?? 0;
    message.preKeyId = object.preKeyId ?? 0;
    message.prePublicKey = object.prePublicKey ?? new Uint8Array(0);
    message.signedPreKeyId = object.signedPreKeyId ?? 0;
    message.signedPrePublicKey = object.signedPrePublicKey ?? new Uint8Array(0);
    message.signedPreKeySignature = object.signedPreKeySignature ?? new Uint8Array(0);
    message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
    message.KEMPreKeyId = object.KEMPreKeyId ?? 0;
    message.KEMPrePublicKey = object.KEMPrePublicKey ?? new Uint8Array(0);
    message.KEMPreKeySignature = object.KEMPreKeySignature ?? new Uint8Array(0);
    return message;
  },
};

function createBasePreKeyBundleEntry(): PreKeyBundleEntry {
  return { id: 0, address: 0n, bundle: undefined, username: "", deviceId: 0 };
}

export const PreKeyBundleEntry: MessageFns<PreKeyBundleEntry> = {
  encode(message: PreKeyBundleEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint32(message.id);
    }
    if (message.address !== 0n) {
      if (BigInt.asUintN(64, message.address) !== message.address) {
        throw new globalThis.Error("value provided for field message.address of type uint64 too large");
      }
      writer.uint32(16).uint64(message.address);
    }
    if (message.bundle !== undefined) {
      PreKeyBundle.encode(message.bundle, writer.uint32(26).fork()).join();
    }
    if (message.username !== "") {
      writer.uint32(34).string(message.username);
    }
    if (message.deviceId !== 0) {
      writer.uint32(40).uint32(message.deviceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundleEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundleEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.address = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bundle = PreKeyBundle.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deviceId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundleEntry {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      address: isSet(object.address) ? BigInt(object.address) : 0n,
      bundle: isSet(object.bundle) ? PreKeyBundle.fromJSON(object.bundle) : undefined,
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
    };
  },

  toJSON(message: PreKeyBundleEntry): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.address !== 0n) {
      obj.address = message.address.toString();
    }
    if (message.bundle !== undefined) {
      obj.bundle = PreKeyBundle.toJSON(message.bundle);
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.deviceId !== 0) {
      obj.deviceId = Math.round(message.deviceId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundleEntry>, I>>(base?: I): PreKeyBundleEntry {
    return PreKeyBundleEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundleEntry>, I>>(object: I): PreKeyBundleEntry {
    const message = createBasePreKeyBundleEntry();
    message.id = object.id ?? 0;
    message.address = object.address ?? 0n;
    message.bundle = (object.bundle !== undefined && object.bundle !== null)
      ? PreKeyBundle.fromPartial(object.bundle)
      : undefined;
    message.username = object.username ?? "";
    message.deviceId = object.deviceId ?? 0;
    return message;
  },
};

function createBasePreKeyBundleEntries(): PreKeyBundleEntries {
  return { entries: [] };
}

export const PreKeyBundleEntries: MessageFns<PreKeyBundleEntries> = {
  encode(message: PreKeyBundleEntries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      PreKeyBundleEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundleEntries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundleEntries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(PreKeyBundleEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundleEntries {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => PreKeyBundleEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PreKeyBundleEntries): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => PreKeyBundleEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundleEntries>, I>>(base?: I): PreKeyBundleEntries {
    return PreKeyBundleEntries.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundleEntries>, I>>(object: I): PreKeyBundleEntries {
    const message = createBasePreKeyBundleEntries();
    message.entries = object.entries?.map((e) => PreKeyBundleEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversationStart(): ConversationStart {
  return { conversationId: 0n, startedBy: "", other: "", bundle: undefined };
}

export const ConversationStart: MessageFns<ConversationStart> = {
  encode(message: ConversationStart, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationId !== 0n) {
      if (BigInt.asUintN(64, message.conversationId) !== message.conversationId) {
        throw new globalThis.Error("value provided for field message.conversationId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.conversationId);
    }
    if (message.startedBy !== "") {
      writer.uint32(18).string(message.startedBy);
    }
    if (message.other !== "") {
      writer.uint32(26).string(message.other);
    }
    if (message.bundle !== undefined) {
      PreKeyBundle.encode(message.bundle, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationStart {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationStart();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.conversationId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.startedBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.other = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bundle = PreKeyBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationStart {
    return {
      conversationId: isSet(object.conversationId) ? BigInt(object.conversationId) : 0n,
      startedBy: isSet(object.startedBy) ? globalThis.String(object.startedBy) : "",
      other: isSet(object.other) ? globalThis.String(object.other) : "",
      bundle: isSet(object.bundle) ? PreKeyBundle.fromJSON(object.bundle) : undefined,
    };
  },

  toJSON(message: ConversationStart): unknown {
    const obj: any = {};
    if (message.conversationId !== 0n) {
      obj.conversationId = message.conversationId.toString();
    }
    if (message.startedBy !== "") {
      obj.startedBy = message.startedBy;
    }
    if (message.other !== "") {
      obj.other = message.other;
    }
    if (message.bundle !== undefined) {
      obj.bundle = PreKeyBundle.toJSON(message.bundle);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConversationStart>, I>>(base?: I): ConversationStart {
    return ConversationStart.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConversationStart>, I>>(object: I): ConversationStart {
    const message = createBaseConversationStart();
    message.conversationId = object.conversationId ?? 0n;
    message.startedBy = object.startedBy ?? "";
    message.other = object.other ?? "";
    message.bundle = (object.bundle !== undefined && object.bundle !== null)
      ? PreKeyBundle.fromPartial(object.bundle)
      : undefined;
    return message;
  },
};

function createBasePreKeyBundles(): PreKeyBundles {
  return { bundles: [] };
}

export const PreKeyBundles: MessageFns<PreKeyBundles> = {
  encode(message: PreKeyBundles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.bundles) {
      PreKeyBundle.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreKeyBundles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreKeyBundles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bundles.push(PreKeyBundle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreKeyBundles {
    return {
      bundles: globalThis.Array.isArray(object?.bundles)
        ? object.bundles.map((e: any) => PreKeyBundle.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PreKeyBundles): unknown {
    const obj: any = {};
    if (message.bundles?.length) {
      obj.bundles = message.bundles.map((e) => PreKeyBundle.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreKeyBundles>, I>>(base?: I): PreKeyBundles {
    return PreKeyBundles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreKeyBundles>, I>>(object: I): PreKeyBundles {
    const message = createBasePreKeyBundles();
    message.bundles = object.bundles?.map((e) => PreKeyBundle.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversation(): Conversation {
  return { user1: "", user2: "", settings: 0n };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user1 !== "") {
      writer.uint32(10).string(message.user1);
    }
    if (message.user2 !== "") {
      writer.uint32(18).string(message.user2);
    }
    if (message.settings !== 0n) {
      if (BigInt.asUintN(64, message.settings) !== message.settings) {
        throw new globalThis.Error("value provided for field message.settings of type uint64 too large");
      }
      writer.uint32(24).uint64(message.settings);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.settings = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      user1: isSet(object.user1) ? globalThis.String(object.user1) : "",
      user2: isSet(object.user2) ? globalThis.String(object.user2) : "",
      settings: isSet(object.settings) ? BigInt(object.settings) : 0n,
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.user1 !== "") {
      obj.user1 = message.user1;
    }
    if (message.user2 !== "") {
      obj.user2 = message.user2;
    }
    if (message.settings !== 0n) {
      obj.settings = message.settings.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversation>, I>>(base?: I): Conversation {
    return Conversation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversation>, I>>(object: I): Conversation {
    const message = createBaseConversation();
    message.user1 = object.user1 ?? "";
    message.user2 = object.user2 ?? "";
    message.settings = object.settings ?? 0n;
    return message;
  },
};

function createBaseConversations(): Conversations {
  return { conversations: [] };
}

export const Conversations: MessageFns<Conversations> = {
  encode(message: Conversations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conversations) {
      Conversation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.conversations.push(Conversation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversations {
    return {
      conversations: globalThis.Array.isArray(object?.conversations)
        ? object.conversations.map((e: any) => Conversation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Conversations): unknown {
    const obj: any = {};
    if (message.conversations?.length) {
      obj.conversations = message.conversations.map((e) => Conversation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Conversations>, I>>(base?: I): Conversations {
    return Conversations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Conversations>, I>>(object: I): Conversations {
    const message = createBaseConversations();
    message.conversations = object.conversations?.map((e) => Conversation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEncryptedFile(): EncryptedFile {
  return { url: "", contentType: 0, secretKey: new Uint8Array(0), contentLength: 0 };
}

export const EncryptedFile: MessageFns<EncryptedFile> = {
  encode(message: EncryptedFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.contentType !== 0) {
      writer.uint32(16).uint32(message.contentType);
    }
    if (message.secretKey.length !== 0) {
      writer.uint32(26).bytes(message.secretKey);
    }
    if (message.contentLength !== 0) {
      writer.uint32(32).uint32(message.contentLength);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.contentType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.secretKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.contentLength = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedFile {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      contentType: isSet(object.contentType) ? globalThis.Number(object.contentType) : 0,
      secretKey: isSet(object.secretKey) ? bytesFromBase64(object.secretKey) : new Uint8Array(0),
      contentLength: isSet(object.contentLength) ? globalThis.Number(object.contentLength) : 0,
    };
  },

  toJSON(message: EncryptedFile): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.contentType !== 0) {
      obj.contentType = Math.round(message.contentType);
    }
    if (message.secretKey.length !== 0) {
      obj.secretKey = base64FromBytes(message.secretKey);
    }
    if (message.contentLength !== 0) {
      obj.contentLength = Math.round(message.contentLength);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptedFile>, I>>(base?: I): EncryptedFile {
    return EncryptedFile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptedFile>, I>>(object: I): EncryptedFile {
    const message = createBaseEncryptedFile();
    message.url = object.url ?? "";
    message.contentType = object.contentType ?? 0;
    message.secretKey = object.secretKey ?? new Uint8Array(0);
    message.contentLength = object.contentLength ?? 0;
    return message;
  },
};

function createBaseEncryptedFiles(): EncryptedFiles {
  return { files: [] };
}

export const EncryptedFiles: MessageFns<EncryptedFiles> = {
  encode(message: EncryptedFiles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      EncryptedFile.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedFiles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedFiles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(EncryptedFile.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedFiles {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => EncryptedFile.fromJSON(e)) : [],
    };
  },

  toJSON(message: EncryptedFiles): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => EncryptedFile.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EncryptedFiles>, I>>(base?: I): EncryptedFiles {
    return EncryptedFiles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EncryptedFiles>, I>>(object: I): EncryptedFiles {
    const message = createBaseEncryptedFiles();
    message.files = object.files?.map((e) => EncryptedFile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessagePayload(): MessagePayload {
  return { text: "", replyingTo: 0n, files: undefined };
}

export const MessagePayload: MessageFns<MessagePayload> = {
  encode(message: MessagePayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.replyingTo !== 0n) {
      if (BigInt.asUintN(64, message.replyingTo) !== message.replyingTo) {
        throw new globalThis.Error("value provided for field message.replyingTo of type uint64 too large");
      }
      writer.uint32(16).uint64(message.replyingTo);
    }
    if (message.files !== undefined) {
      EncryptedFiles.encode(message.files, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessagePayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessagePayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.replyingTo = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.files = EncryptedFiles.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessagePayload {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      replyingTo: isSet(object.replyingTo) ? BigInt(object.replyingTo) : 0n,
      files: isSet(object.files) ? EncryptedFiles.fromJSON(object.files) : undefined,
    };
  },

  toJSON(message: MessagePayload): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.replyingTo !== 0n) {
      obj.replyingTo = message.replyingTo.toString();
    }
    if (message.files !== undefined) {
      obj.files = EncryptedFiles.toJSON(message.files);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessagePayload>, I>>(base?: I): MessagePayload {
    return MessagePayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessagePayload>, I>>(object: I): MessagePayload {
    const message = createBaseMessagePayload();
    message.text = object.text ?? "";
    message.replyingTo = object.replyingTo ?? 0n;
    message.files = (object.files !== undefined && object.files !== null)
      ? EncryptedFiles.fromPartial(object.files)
      : undefined;
    return message;
  },
};

function createBaseCallMessage(): CallMessage {
  return { message: new Uint8Array(0), sessionId: 0, type: 0, jsonBody: "" };
}

export const CallMessage: MessageFns<CallMessage> = {
  encode(message: CallMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message.length !== 0) {
      writer.uint32(10).bytes(message.message);
    }
    if (message.sessionId !== 0) {
      writer.uint32(16).uint32(message.sessionId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.jsonBody !== "") {
      writer.uint32(34).string(message.jsonBody);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sessionId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jsonBody = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallMessage {
    return {
      message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
      sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
      type: isSet(object.type) ? callMessageTypeFromJSON(object.type) : 0,
      jsonBody: isSet(object.jsonBody) ? globalThis.String(object.jsonBody) : "",
    };
  },

  toJSON(message: CallMessage): unknown {
    const obj: any = {};
    if (message.message.length !== 0) {
      obj.message = base64FromBytes(message.message);
    }
    if (message.sessionId !== 0) {
      obj.sessionId = Math.round(message.sessionId);
    }
    if (message.type !== 0) {
      obj.type = callMessageTypeToJSON(message.type);
    }
    if (message.jsonBody !== "") {
      obj.jsonBody = message.jsonBody;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CallMessage>, I>>(base?: I): CallMessage {
    return CallMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CallMessage>, I>>(object: I): CallMessage {
    const message = createBaseCallMessage();
    message.message = object.message ?? new Uint8Array(0);
    message.sessionId = object.sessionId ?? 0;
    message.type = object.type ?? 0;
    message.jsonBody = object.jsonBody ?? "";
    return message;
  },
};

function createBaseSelfUserMessage(): SelfUserMessage {
  return { to: "", inner: new Uint8Array(0) };
}

export const SelfUserMessage: MessageFns<SelfUserMessage> = {
  encode(message: SelfUserMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.to !== "") {
      writer.uint32(10).string(message.to);
    }
    if (message.inner.length !== 0) {
      writer.uint32(18).bytes(message.inner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SelfUserMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelfUserMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inner = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SelfUserMessage {
    return {
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      inner: isSet(object.inner) ? bytesFromBase64(object.inner) : new Uint8Array(0),
    };
  },

  toJSON(message: SelfUserMessage): unknown {
    const obj: any = {};
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.inner.length !== 0) {
      obj.inner = base64FromBytes(message.inner);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SelfUserMessage>, I>>(base?: I): SelfUserMessage {
    return SelfUserMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SelfUserMessage>, I>>(object: I): SelfUserMessage {
    const message = createBaseSelfUserMessage();
    message.to = object.to ?? "";
    message.inner = object.inner ?? new Uint8Array(0);
    return message;
  },
};

function createBaseUserMessageInner(): UserMessageInner {
  return { plainText: undefined, callMessage: undefined, messagePayload: undefined, selfMessage: undefined };
}

export const UserMessageInner: MessageFns<UserMessageInner> = {
  encode(message: UserMessageInner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.plainText !== undefined) {
      writer.uint32(10).bytes(message.plainText);
    }
    if (message.callMessage !== undefined) {
      CallMessage.encode(message.callMessage, writer.uint32(18).fork()).join();
    }
    if (message.messagePayload !== undefined) {
      MessagePayload.encode(message.messagePayload, writer.uint32(26).fork()).join();
    }
    if (message.selfMessage !== undefined) {
      SelfUserMessage.encode(message.selfMessage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserMessageInner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserMessageInner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.plainText = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callMessage = CallMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messagePayload = MessagePayload.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.selfMessage = SelfUserMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserMessageInner {
    return {
      plainText: isSet(object.plainText) ? bytesFromBase64(object.plainText) : undefined,
      callMessage: isSet(object.callMessage) ? CallMessage.fromJSON(object.callMessage) : undefined,
      messagePayload: isSet(object.messagePayload) ? MessagePayload.fromJSON(object.messagePayload) : undefined,
      selfMessage: isSet(object.selfMessage) ? SelfUserMessage.fromJSON(object.selfMessage) : undefined,
    };
  },

  toJSON(message: UserMessageInner): unknown {
    const obj: any = {};
    if (message.plainText !== undefined) {
      obj.plainText = base64FromBytes(message.plainText);
    }
    if (message.callMessage !== undefined) {
      obj.callMessage = CallMessage.toJSON(message.callMessage);
    }
    if (message.messagePayload !== undefined) {
      obj.messagePayload = MessagePayload.toJSON(message.messagePayload);
    }
    if (message.selfMessage !== undefined) {
      obj.selfMessage = SelfUserMessage.toJSON(message.selfMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserMessageInner>, I>>(base?: I): UserMessageInner {
    return UserMessageInner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserMessageInner>, I>>(object: I): UserMessageInner {
    const message = createBaseUserMessageInner();
    message.plainText = object.plainText ?? undefined;
    message.callMessage = (object.callMessage !== undefined && object.callMessage !== null)
      ? CallMessage.fromPartial(object.callMessage)
      : undefined;
    message.messagePayload = (object.messagePayload !== undefined && object.messagePayload !== null)
      ? MessagePayload.fromPartial(object.messagePayload)
      : undefined;
    message.selfMessage = (object.selfMessage !== undefined && object.selfMessage !== null)
      ? SelfUserMessage.fromPartial(object.selfMessage)
      : undefined;
    return message;
  },
};

function createBaseGroupMessageInner(): GroupMessageInner {
  return { channelId: 0, messagePayload: undefined };
}

export const GroupMessageInner: MessageFns<GroupMessageInner> = {
  encode(message: GroupMessageInner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== 0) {
      writer.uint32(8).uint32(message.channelId);
    }
    if (message.messagePayload !== undefined) {
      MessagePayload.encode(message.messagePayload, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GroupMessageInner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupMessageInner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.channelId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.messagePayload = MessagePayload.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupMessageInner {
    return {
      channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
      messagePayload: isSet(object.messagePayload) ? MessagePayload.fromJSON(object.messagePayload) : undefined,
    };
  },

  toJSON(message: GroupMessageInner): unknown {
    const obj: any = {};
    if (message.channelId !== 0) {
      obj.channelId = Math.round(message.channelId);
    }
    if (message.messagePayload !== undefined) {
      obj.messagePayload = MessagePayload.toJSON(message.messagePayload);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GroupMessageInner>, I>>(base?: I): GroupMessageInner {
    return GroupMessageInner.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GroupMessageInner>, I>>(object: I): GroupMessageInner {
    const message = createBaseGroupMessageInner();
    message.channelId = object.channelId ?? 0;
    message.messagePayload = (object.messagePayload !== undefined && object.messagePayload !== null)
      ? MessagePayload.fromPartial(object.messagePayload)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
