"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v6.33.1
// source: message.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.EncryptedFiles = exports.EncryptedFile = exports.Conversations = exports.Conversation = exports.PreKeyBundles = exports.ConversationStart = exports.PreKeyBundleEntries = exports.PreKeyBundleEntry = exports.PreKeyBundle = exports.FireflyGroupChannels = exports.FireflyGroupChannel = exports.FireflyGroupMembers = exports.FireflyGroupMember = exports.FireflyGroupRoles = exports.FireflyGroupRole = exports.FireflyGroupExtension = exports.FireflyIdentity = exports.SignedToken = exports.AuthToken = exports.GroupId = exports.ClientMessage = exports.UnSubscribeGroup = exports.SubscribeGroup = exports.ServerMessage = exports.Response = exports.Request = exports.UserMessageUploaded = exports.MessageIdAndTo = exports.UploadUserMessage = exports.Addresses = exports.Address = exports.Result = exports.Error = exports.GroupReAddRequests = exports.GroupReAddRequest = exports.GroupSyncRequests = exports.GroupSyncRequest = exports.GroupMessages = exports.GroupKeyPackages = exports.GroupKeyPackage = exports.GroupMessage = exports.GroupInvites = exports.GroupCommitAndWelcome = exports.GroupInvite = exports.UserMessages = exports.Groups = exports.Group = exports.UserMessage = exports.CallMessageType = exports.protobufPackage = void 0;
exports.GroupMessageInner = exports.UserMessageInner = exports.SelfUserMessage = exports.CallMessage = exports.MessagePayload = void 0;
exports.callMessageTypeFromJSON = callMessageTypeFromJSON;
exports.callMessageTypeToJSON = callMessageTypeToJSON;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
exports.protobufPackage = "firefly";
var CallMessageType;
(function (CallMessageType) {
    CallMessageType[CallMessageType["none"] = 0] = "none";
    CallMessageType[CallMessageType["request"] = 1] = "request";
    CallMessageType[CallMessageType["reject"] = 2] = "reject";
    CallMessageType[CallMessageType["end"] = 3] = "end";
    /** ended - for saving call messages */
    CallMessageType[CallMessageType["ended"] = 4] = "ended";
    CallMessageType[CallMessageType["rejected"] = 5] = "rejected";
    /** candidate - webrtc messages */
    CallMessageType[CallMessageType["candidate"] = 10] = "candidate";
    CallMessageType[CallMessageType["answer"] = 11] = "answer";
    CallMessageType[CallMessageType["offer"] = 12] = "offer";
    CallMessageType[CallMessageType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CallMessageType || (exports.CallMessageType = CallMessageType = {}));
function callMessageTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "none":
            return CallMessageType.none;
        case 1:
        case "request":
            return CallMessageType.request;
        case 2:
        case "reject":
            return CallMessageType.reject;
        case 3:
        case "end":
            return CallMessageType.end;
        case 4:
        case "ended":
            return CallMessageType.ended;
        case 5:
        case "rejected":
            return CallMessageType.rejected;
        case 10:
        case "candidate":
            return CallMessageType.candidate;
        case 11:
        case "answer":
            return CallMessageType.answer;
        case 12:
        case "offer":
            return CallMessageType.offer;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CallMessageType.UNRECOGNIZED;
    }
}
function callMessageTypeToJSON(object) {
    switch (object) {
        case CallMessageType.none:
            return "none";
        case CallMessageType.request:
            return "request";
        case CallMessageType.reject:
            return "reject";
        case CallMessageType.end:
            return "end";
        case CallMessageType.ended:
            return "ended";
        case CallMessageType.rejected:
            return "rejected";
        case CallMessageType.candidate:
            return "candidate";
        case CallMessageType.answer:
            return "answer";
        case CallMessageType.offer:
            return "offer";
        case CallMessageType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseUserMessage() {
    return {
        id: 0n,
        toId: 0n,
        fromId: 0n,
        text: new Uint8Array(0),
        type: 0,
        settings: 0,
        fromUsername: "",
        fromDeviceId: 0,
    };
}
exports.UserMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.toId !== 0n) {
            if (BigInt.asUintN(64, message.toId) !== message.toId) {
                throw new globalThis.Error("value provided for field message.toId of type uint64 too large");
            }
            writer.uint32(16).uint64(message.toId);
        }
        if (message.fromId !== 0n) {
            if (BigInt.asUintN(64, message.fromId) !== message.fromId) {
                throw new globalThis.Error("value provided for field message.fromId of type uint64 too large");
            }
            writer.uint32(24).uint64(message.fromId);
        }
        if (message.text.length !== 0) {
            writer.uint32(34).bytes(message.text);
        }
        if (message.type !== 0) {
            writer.uint32(48).uint32(message.type);
        }
        if (message.settings !== 0) {
            writer.uint32(56).uint32(message.settings);
        }
        if (message.fromUsername !== "") {
            writer.uint32(66).string(message.fromUsername);
        }
        if (message.fromDeviceId !== 0) {
            writer.uint32(72).uint32(message.fromDeviceId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.toId = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.fromId = reader.uint64();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.text = reader.bytes();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.type = reader.uint32();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.settings = reader.uint32();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.fromUsername = reader.string();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.fromDeviceId = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            toId: isSet(object.toId) ? BigInt(object.toId) : 0n,
            fromId: isSet(object.fromId) ? BigInt(object.fromId) : 0n,
            text: isSet(object.text) ? bytesFromBase64(object.text) : new Uint8Array(0),
            type: isSet(object.type) ? globalThis.Number(object.type) : 0,
            settings: isSet(object.settings) ? globalThis.Number(object.settings) : 0,
            fromUsername: isSet(object.fromUsername) ? globalThis.String(object.fromUsername) : "",
            fromDeviceId: isSet(object.fromDeviceId) ? globalThis.Number(object.fromDeviceId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.toId !== 0n) {
            obj.toId = message.toId.toString();
        }
        if (message.fromId !== 0n) {
            obj.fromId = message.fromId.toString();
        }
        if (message.text.length !== 0) {
            obj.text = base64FromBytes(message.text);
        }
        if (message.type !== 0) {
            obj.type = Math.round(message.type);
        }
        if (message.settings !== 0) {
            obj.settings = Math.round(message.settings);
        }
        if (message.fromUsername !== "") {
            obj.fromUsername = message.fromUsername;
        }
        if (message.fromDeviceId !== 0) {
            obj.fromDeviceId = Math.round(message.fromDeviceId);
        }
        return obj;
    },
    create(base) {
        return exports.UserMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserMessage();
        message.id = object.id ?? 0n;
        message.toId = object.toId ?? 0n;
        message.fromId = object.fromId ?? 0n;
        message.text = object.text ?? new Uint8Array(0);
        message.type = object.type ?? 0;
        message.settings = object.settings ?? 0;
        message.fromUsername = object.fromUsername ?? "";
        message.fromDeviceId = object.fromDeviceId ?? 0;
        return message;
    },
};
function createBaseGroup() {
    return { id: 0n, name: "", description: "", pfp: false, state: new Uint8Array(0) };
}
exports.Group = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.pfp !== false) {
            writer.uint32(32).bool(message.pfp);
        }
        if (message.state.length !== 0) {
            writer.uint32(42).bytes(message.state);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroup();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.pfp = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.state = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            pfp: isSet(object.pfp) ? globalThis.Boolean(object.pfp) : false,
            state: isSet(object.state) ? bytesFromBase64(object.state) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.pfp !== false) {
            obj.pfp = message.pfp;
        }
        if (message.state.length !== 0) {
            obj.state = base64FromBytes(message.state);
        }
        return obj;
    },
    create(base) {
        return exports.Group.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroup();
        message.id = object.id ?? 0n;
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.pfp = object.pfp ?? false;
        message.state = object.state ?? new Uint8Array(0);
        return message;
    },
};
function createBaseGroups() {
    return { groups: [] };
}
exports.Groups = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.groups) {
            exports.Group.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroups();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.groups.push(exports.Group.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { groups: globalThis.Array.isArray(object?.groups) ? object.groups.map((e) => exports.Group.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.groups?.length) {
            obj.groups = message.groups.map((e) => exports.Group.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Groups.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroups();
        message.groups = object.groups?.map((e) => exports.Group.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUserMessages() {
    return { messages: [] };
}
exports.UserMessages = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.messages) {
            exports.UserMessage.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserMessages();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.messages.push(exports.UserMessage.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: globalThis.Array.isArray(object?.messages)
                ? object.messages.map((e) => exports.UserMessage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages?.length) {
            obj.messages = message.messages.map((e) => exports.UserMessage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.UserMessages.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserMessages();
        message.messages = object.messages?.map((e) => exports.UserMessage.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGroupInvite() {
    return { groupId: 0n, inviter: "", invitee: "", welcomeMessage: new Uint8Array(0), commitId: 0n };
}
exports.GroupInvite = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupId !== 0n) {
            if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
                throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.groupId);
        }
        if (message.inviter !== "") {
            writer.uint32(18).string(message.inviter);
        }
        if (message.invitee !== "") {
            writer.uint32(26).string(message.invitee);
        }
        if (message.welcomeMessage.length !== 0) {
            writer.uint32(34).bytes(message.welcomeMessage);
        }
        if (message.commitId !== 0n) {
            if (BigInt.asUintN(64, message.commitId) !== message.commitId) {
                throw new globalThis.Error("value provided for field message.commitId of type uint64 too large");
            }
            writer.uint32(40).uint64(message.commitId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupInvite();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.groupId = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.inviter = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.invitee = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.welcomeMessage = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.commitId = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
            inviter: isSet(object.inviter) ? globalThis.String(object.inviter) : "",
            invitee: isSet(object.invitee) ? globalThis.String(object.invitee) : "",
            welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array(0),
            commitId: isSet(object.commitId) ? BigInt(object.commitId) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.groupId !== 0n) {
            obj.groupId = message.groupId.toString();
        }
        if (message.inviter !== "") {
            obj.inviter = message.inviter;
        }
        if (message.invitee !== "") {
            obj.invitee = message.invitee;
        }
        if (message.welcomeMessage.length !== 0) {
            obj.welcomeMessage = base64FromBytes(message.welcomeMessage);
        }
        if (message.commitId !== 0n) {
            obj.commitId = message.commitId.toString();
        }
        return obj;
    },
    create(base) {
        return exports.GroupInvite.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupInvite();
        message.groupId = object.groupId ?? 0n;
        message.inviter = object.inviter ?? "";
        message.invitee = object.invitee ?? "";
        message.welcomeMessage = object.welcomeMessage ?? new Uint8Array(0);
        message.commitId = object.commitId ?? 0n;
        return message;
    },
};
function createBaseGroupCommitAndWelcome() {
    return {
        id: 0n,
        groupId: 0n,
        commitMessage: new Uint8Array(0),
        inviter: "",
        invitee: "",
        welcomeMessage: new Uint8Array(0),
        inviteeAddresses: [],
    };
}
exports.GroupCommitAndWelcome = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.groupId !== 0n) {
            if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
                throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
            }
            writer.uint32(16).uint64(message.groupId);
        }
        if (message.commitMessage.length !== 0) {
            writer.uint32(26).bytes(message.commitMessage);
        }
        if (message.inviter !== "") {
            writer.uint32(34).string(message.inviter);
        }
        if (message.invitee !== "") {
            writer.uint32(42).string(message.invitee);
        }
        if (message.welcomeMessage.length !== 0) {
            writer.uint32(50).bytes(message.welcomeMessage);
        }
        writer.uint32(58).fork();
        for (const v of message.inviteeAddresses) {
            if (BigInt.asUintN(64, v) !== v) {
                throw new globalThis.Error("a value provided in array field inviteeAddresses of type uint64 is too large");
            }
            writer.uint64(v);
        }
        writer.join();
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupCommitAndWelcome();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.groupId = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.commitMessage = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.inviter = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.invitee = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.welcomeMessage = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag === 56) {
                        message.inviteeAddresses.push(reader.uint64());
                        continue;
                    }
                    if (tag === 58) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.inviteeAddresses.push(reader.uint64());
                        }
                        continue;
                    }
                    break;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
            commitMessage: isSet(object.commitMessage) ? bytesFromBase64(object.commitMessage) : new Uint8Array(0),
            inviter: isSet(object.inviter) ? globalThis.String(object.inviter) : "",
            invitee: isSet(object.invitee) ? globalThis.String(object.invitee) : "",
            welcomeMessage: isSet(object.welcomeMessage) ? bytesFromBase64(object.welcomeMessage) : new Uint8Array(0),
            inviteeAddresses: globalThis.Array.isArray(object?.inviteeAddresses)
                ? object.inviteeAddresses.map((e) => BigInt(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.groupId !== 0n) {
            obj.groupId = message.groupId.toString();
        }
        if (message.commitMessage.length !== 0) {
            obj.commitMessage = base64FromBytes(message.commitMessage);
        }
        if (message.inviter !== "") {
            obj.inviter = message.inviter;
        }
        if (message.invitee !== "") {
            obj.invitee = message.invitee;
        }
        if (message.welcomeMessage.length !== 0) {
            obj.welcomeMessage = base64FromBytes(message.welcomeMessage);
        }
        if (message.inviteeAddresses?.length) {
            obj.inviteeAddresses = message.inviteeAddresses.map((e) => e.toString());
        }
        return obj;
    },
    create(base) {
        return exports.GroupCommitAndWelcome.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupCommitAndWelcome();
        message.id = object.id ?? 0n;
        message.groupId = object.groupId ?? 0n;
        message.commitMessage = object.commitMessage ?? new Uint8Array(0);
        message.inviter = object.inviter ?? "";
        message.invitee = object.invitee ?? "";
        message.welcomeMessage = object.welcomeMessage ?? new Uint8Array(0);
        message.inviteeAddresses = object.inviteeAddresses?.map((e) => e) || [];
        return message;
    },
};
function createBaseGroupInvites() {
    return { invites: [] };
}
exports.GroupInvites = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.invites) {
            exports.GroupInvite.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupInvites();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.invites.push(exports.GroupInvite.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            invites: globalThis.Array.isArray(object?.invites) ? object.invites.map((e) => exports.GroupInvite.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.invites?.length) {
            obj.invites = message.invites.map((e) => exports.GroupInvite.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GroupInvites.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupInvites();
        message.invites = object.invites?.map((e) => exports.GroupInvite.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGroupMessage() {
    return { id: 0n, groupId: 0n, message: new Uint8Array(0) };
}
exports.GroupMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.groupId !== 0n) {
            if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
                throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
            }
            writer.uint32(16).uint64(message.groupId);
        }
        if (message.message.length !== 0) {
            writer.uint32(26).bytes(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.groupId = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.message = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
            message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.groupId !== 0n) {
            obj.groupId = message.groupId.toString();
        }
        if (message.message.length !== 0) {
            obj.message = base64FromBytes(message.message);
        }
        return obj;
    },
    create(base) {
        return exports.GroupMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupMessage();
        message.id = object.id ?? 0n;
        message.groupId = object.groupId ?? 0n;
        message.message = object.message ?? new Uint8Array(0);
        return message;
    },
};
function createBaseGroupKeyPackage() {
    return { id: 0, package: new Uint8Array(0), address: 0n, username: "" };
}
exports.GroupKeyPackage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).int32(message.id);
        }
        if (message.package.length !== 0) {
            writer.uint32(18).bytes(message.package);
        }
        if (message.address !== 0n) {
            if (BigInt.asUintN(64, message.address) !== message.address) {
                throw new globalThis.Error("value provided for field message.address of type uint64 too large");
            }
            writer.uint32(24).uint64(message.address);
        }
        if (message.username !== "") {
            writer.uint32(34).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupKeyPackage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.package = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.address = reader.uint64();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            package: isSet(object.package) ? bytesFromBase64(object.package) : new Uint8Array(0),
            address: isSet(object.address) ? BigInt(object.address) : 0n,
            username: isSet(object.username) ? globalThis.String(object.username) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.package.length !== 0) {
            obj.package = base64FromBytes(message.package);
        }
        if (message.address !== 0n) {
            obj.address = message.address.toString();
        }
        if (message.username !== "") {
            obj.username = message.username;
        }
        return obj;
    },
    create(base) {
        return exports.GroupKeyPackage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupKeyPackage();
        message.id = object.id ?? 0;
        message.package = object.package ?? new Uint8Array(0);
        message.address = object.address ?? 0n;
        message.username = object.username ?? "";
        return message;
    },
};
function createBaseGroupKeyPackages() {
    return { packages: [] };
}
exports.GroupKeyPackages = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.packages) {
            exports.GroupKeyPackage.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupKeyPackages();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.packages.push(exports.GroupKeyPackage.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            packages: globalThis.Array.isArray(object?.packages)
                ? object.packages.map((e) => exports.GroupKeyPackage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.packages?.length) {
            obj.packages = message.packages.map((e) => exports.GroupKeyPackage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GroupKeyPackages.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupKeyPackages();
        message.packages = object.packages?.map((e) => exports.GroupKeyPackage.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGroupMessages() {
    return { messages: [] };
}
exports.GroupMessages = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.messages) {
            exports.GroupMessage.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessages();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.messages.push(exports.GroupMessage.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: globalThis.Array.isArray(object?.messages)
                ? object.messages.map((e) => exports.GroupMessage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages?.length) {
            obj.messages = message.messages.map((e) => exports.GroupMessage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GroupMessages.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupMessages();
        message.messages = object.messages?.map((e) => exports.GroupMessage.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGroupSyncRequest() {
    return { groupId: 0n, startAfter: 0n, until: 0n, limit: 0 };
}
exports.GroupSyncRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupId !== 0n) {
            if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
                throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.groupId);
        }
        if (message.startAfter !== 0n) {
            if (BigInt.asUintN(64, message.startAfter) !== message.startAfter) {
                throw new globalThis.Error("value provided for field message.startAfter of type uint64 too large");
            }
            writer.uint32(16).uint64(message.startAfter);
        }
        if (message.until !== 0n) {
            if (BigInt.asUintN(64, message.until) !== message.until) {
                throw new globalThis.Error("value provided for field message.until of type uint64 too large");
            }
            writer.uint32(24).uint64(message.until);
        }
        if (message.limit !== 0) {
            writer.uint32(32).uint32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupSyncRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.groupId = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.startAfter = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.until = reader.uint64();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.limit = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
            startAfter: isSet(object.startAfter) ? BigInt(object.startAfter) : 0n,
            until: isSet(object.until) ? BigInt(object.until) : 0n,
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.groupId !== 0n) {
            obj.groupId = message.groupId.toString();
        }
        if (message.startAfter !== 0n) {
            obj.startAfter = message.startAfter.toString();
        }
        if (message.until !== 0n) {
            obj.until = message.until.toString();
        }
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        return obj;
    },
    create(base) {
        return exports.GroupSyncRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupSyncRequest();
        message.groupId = object.groupId ?? 0n;
        message.startAfter = object.startAfter ?? 0n;
        message.until = object.until ?? 0n;
        message.limit = object.limit ?? 0;
        return message;
    },
};
function createBaseGroupSyncRequests() {
    return { requests: [] };
}
exports.GroupSyncRequests = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.requests) {
            exports.GroupSyncRequest.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupSyncRequests();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requests.push(exports.GroupSyncRequest.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            requests: globalThis.Array.isArray(object?.requests)
                ? object.requests.map((e) => exports.GroupSyncRequest.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requests?.length) {
            obj.requests = message.requests.map((e) => exports.GroupSyncRequest.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GroupSyncRequests.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupSyncRequests();
        message.requests = object.requests?.map((e) => exports.GroupSyncRequest.fromPartial(e)) || [];
        return message;
    },
};
function createBaseGroupReAddRequest() {
    return { groupId: 0n, addressId: 0n, username: "" };
}
exports.GroupReAddRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupId !== 0n) {
            if (BigInt.asUintN(64, message.groupId) !== message.groupId) {
                throw new globalThis.Error("value provided for field message.groupId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.groupId);
        }
        if (message.addressId !== 0n) {
            if (BigInt.asUintN(64, message.addressId) !== message.addressId) {
                throw new globalThis.Error("value provided for field message.addressId of type uint64 too large");
            }
            writer.uint32(16).uint64(message.addressId);
        }
        if (message.username !== "") {
            writer.uint32(26).string(message.username);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupReAddRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.groupId = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.addressId = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            groupId: isSet(object.groupId) ? BigInt(object.groupId) : 0n,
            addressId: isSet(object.addressId) ? BigInt(object.addressId) : 0n,
            username: isSet(object.username) ? globalThis.String(object.username) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.groupId !== 0n) {
            obj.groupId = message.groupId.toString();
        }
        if (message.addressId !== 0n) {
            obj.addressId = message.addressId.toString();
        }
        if (message.username !== "") {
            obj.username = message.username;
        }
        return obj;
    },
    create(base) {
        return exports.GroupReAddRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupReAddRequest();
        message.groupId = object.groupId ?? 0n;
        message.addressId = object.addressId ?? 0n;
        message.username = object.username ?? "";
        return message;
    },
};
function createBaseGroupReAddRequests() {
    return { requests: [] };
}
exports.GroupReAddRequests = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.requests) {
            exports.GroupReAddRequest.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupReAddRequests();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.requests.push(exports.GroupReAddRequest.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            requests: globalThis.Array.isArray(object?.requests)
                ? object.requests.map((e) => exports.GroupReAddRequest.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requests?.length) {
            obj.requests = message.requests.map((e) => exports.GroupReAddRequest.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.GroupReAddRequests.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupReAddRequests();
        message.requests = object.requests?.map((e) => exports.GroupReAddRequest.fromPartial(e)) || [];
        return message;
    },
};
function createBaseError() {
    return { errorCode: 0, error: "" };
}
exports.Error = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.errorCode !== 0) {
            writer.uint32(8).uint32(message.errorCode);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseError();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.errorCode = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            errorCode: isSet(object.errorCode) ? globalThis.Number(object.errorCode) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.errorCode !== 0) {
            obj.errorCode = Math.round(message.errorCode);
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return exports.Error.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseError();
        message.errorCode = object.errorCode ?? 0;
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseResult() {
    return { resultCode: 0, body: new Uint8Array(0) };
}
exports.Result = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.resultCode !== 0) {
            writer.uint32(8).uint32(message.resultCode);
        }
        if (message.body.length !== 0) {
            writer.uint32(18).bytes(message.body);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.resultCode = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.body = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            resultCode: isSet(object.resultCode) ? globalThis.Number(object.resultCode) : 0,
            body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.resultCode !== 0) {
            obj.resultCode = Math.round(message.resultCode);
        }
        if (message.body.length !== 0) {
            obj.body = base64FromBytes(message.body);
        }
        return obj;
    },
    create(base) {
        return exports.Result.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResult();
        message.resultCode = object.resultCode ?? 0;
        message.body = object.body ?? new Uint8Array(0);
        return message;
    },
};
function createBaseAddress() {
    return { id: 0n, username: "", deviceId: 0, fcmToken: "" };
}
exports.Address = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.username !== "") {
            writer.uint32(18).string(message.username);
        }
        if (message.deviceId !== 0) {
            writer.uint32(24).uint32(message.deviceId);
        }
        if (message.fcmToken !== "") {
            writer.uint32(34).string(message.fcmToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.deviceId = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.fcmToken = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            username: isSet(object.username) ? globalThis.String(object.username) : "",
            deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
            fcmToken: isSet(object.fcmToken) ? globalThis.String(object.fcmToken) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.username !== "") {
            obj.username = message.username;
        }
        if (message.deviceId !== 0) {
            obj.deviceId = Math.round(message.deviceId);
        }
        if (message.fcmToken !== "") {
            obj.fcmToken = message.fcmToken;
        }
        return obj;
    },
    create(base) {
        return exports.Address.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddress();
        message.id = object.id ?? 0n;
        message.username = object.username ?? "";
        message.deviceId = object.deviceId ?? 0;
        message.fcmToken = object.fcmToken ?? "";
        return message;
    },
};
function createBaseAddresses() {
    return { addresses: [] };
}
exports.Addresses = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.addresses) {
            exports.Address.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAddresses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.addresses.push(exports.Address.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            addresses: globalThis.Array.isArray(object?.addresses)
                ? object.addresses.map((e) => exports.Address.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.addresses?.length) {
            obj.addresses = message.addresses.map((e) => exports.Address.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Addresses.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAddresses();
        message.addresses = object.addresses?.map((e) => exports.Address.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUploadUserMessage() {
    return { messages: [] };
}
exports.UploadUserMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.messages) {
            exports.UserMessage.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUploadUserMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.messages.push(exports.UserMessage.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: globalThis.Array.isArray(object?.messages)
                ? object.messages.map((e) => exports.UserMessage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages?.length) {
            obj.messages = message.messages.map((e) => exports.UserMessage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.UploadUserMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUploadUserMessage();
        message.messages = object.messages?.map((e) => exports.UserMessage.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMessageIdAndTo() {
    return { id: 0n, to: 0n, isSelf: false };
}
exports.MessageIdAndTo = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        if (message.to !== 0n) {
            if (BigInt.asUintN(64, message.to) !== message.to) {
                throw new globalThis.Error("value provided for field message.to of type uint64 too large");
            }
            writer.uint32(16).uint64(message.to);
        }
        if (message.isSelf !== false) {
            writer.uint32(24).bool(message.isSelf);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageIdAndTo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.to = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.isSelf = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? BigInt(object.id) : 0n,
            to: isSet(object.to) ? BigInt(object.to) : 0n,
            isSelf: isSet(object.isSelf) ? globalThis.Boolean(object.isSelf) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        if (message.to !== 0n) {
            obj.to = message.to.toString();
        }
        if (message.isSelf !== false) {
            obj.isSelf = message.isSelf;
        }
        return obj;
    },
    create(base) {
        return exports.MessageIdAndTo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessageIdAndTo();
        message.id = object.id ?? 0n;
        message.to = object.to ?? 0n;
        message.isSelf = object.isSelf ?? false;
        return message;
    },
};
function createBaseUserMessageUploaded() {
    return { messageIds: [] };
}
exports.UserMessageUploaded = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.messageIds) {
            exports.MessageIdAndTo.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserMessageUploaded();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.messageIds.push(exports.MessageIdAndTo.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messageIds: globalThis.Array.isArray(object?.messageIds)
                ? object.messageIds.map((e) => exports.MessageIdAndTo.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messageIds?.length) {
            obj.messageIds = message.messageIds.map((e) => exports.MessageIdAndTo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.UserMessageUploaded.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserMessageUploaded();
        message.messageIds = object.messageIds?.map((e) => exports.MessageIdAndTo.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRequest() {
    return { id: 0, createUserMessage: undefined, uploadUserMessage: undefined, uploadGroupMessage: undefined };
}
exports.Request = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.createUserMessage !== undefined) {
            exports.UserMessage.encode(message.createUserMessage, writer.uint32(18).fork()).join();
        }
        if (message.uploadUserMessage !== undefined) {
            exports.UploadUserMessage.encode(message.uploadUserMessage, writer.uint32(26).fork()).join();
        }
        if (message.uploadGroupMessage !== undefined) {
            exports.GroupMessage.encode(message.uploadGroupMessage, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.createUserMessage = exports.UserMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.uploadUserMessage = exports.UploadUserMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.uploadGroupMessage = exports.GroupMessage.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            createUserMessage: isSet(object.createUserMessage) ? exports.UserMessage.fromJSON(object.createUserMessage) : undefined,
            uploadUserMessage: isSet(object.uploadUserMessage)
                ? exports.UploadUserMessage.fromJSON(object.uploadUserMessage)
                : undefined,
            uploadGroupMessage: isSet(object.uploadGroupMessage)
                ? exports.GroupMessage.fromJSON(object.uploadGroupMessage)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.createUserMessage !== undefined) {
            obj.createUserMessage = exports.UserMessage.toJSON(message.createUserMessage);
        }
        if (message.uploadUserMessage !== undefined) {
            obj.uploadUserMessage = exports.UploadUserMessage.toJSON(message.uploadUserMessage);
        }
        if (message.uploadGroupMessage !== undefined) {
            obj.uploadGroupMessage = exports.GroupMessage.toJSON(message.uploadGroupMessage);
        }
        return obj;
    },
    create(base) {
        return exports.Request.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequest();
        message.id = object.id ?? 0;
        message.createUserMessage = (object.createUserMessage !== undefined && object.createUserMessage !== null)
            ? exports.UserMessage.fromPartial(object.createUserMessage)
            : undefined;
        message.uploadUserMessage = (object.uploadUserMessage !== undefined && object.uploadUserMessage !== null)
            ? exports.UploadUserMessage.fromPartial(object.uploadUserMessage)
            : undefined;
        message.uploadGroupMessage = (object.uploadGroupMessage !== undefined && object.uploadGroupMessage !== null)
            ? exports.GroupMessage.fromPartial(object.uploadGroupMessage)
            : undefined;
        return message;
    },
};
function createBaseResponse() {
    return {
        id: 0,
        error: undefined,
        createdUserMessage: undefined,
        userMessageUploaded: undefined,
        groupMessageUploaded: undefined,
    };
}
exports.Response = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.error !== undefined) {
            exports.Error.encode(message.error, writer.uint32(18).fork()).join();
        }
        if (message.createdUserMessage !== undefined) {
            exports.UserMessage.encode(message.createdUserMessage, writer.uint32(26).fork()).join();
        }
        if (message.userMessageUploaded !== undefined) {
            exports.UserMessageUploaded.encode(message.userMessageUploaded, writer.uint32(34).fork()).join();
        }
        if (message.groupMessageUploaded !== undefined) {
            exports.GroupMessage.encode(message.groupMessageUploaded, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.error = exports.Error.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.createdUserMessage = exports.UserMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.userMessageUploaded = exports.UserMessageUploaded.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.groupMessageUploaded = exports.GroupMessage.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            error: isSet(object.error) ? exports.Error.fromJSON(object.error) : undefined,
            createdUserMessage: isSet(object.createdUserMessage)
                ? exports.UserMessage.fromJSON(object.createdUserMessage)
                : undefined,
            userMessageUploaded: isSet(object.userMessageUploaded)
                ? exports.UserMessageUploaded.fromJSON(object.userMessageUploaded)
                : undefined,
            groupMessageUploaded: isSet(object.groupMessageUploaded)
                ? exports.GroupMessage.fromJSON(object.groupMessageUploaded)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.error !== undefined) {
            obj.error = exports.Error.toJSON(message.error);
        }
        if (message.createdUserMessage !== undefined) {
            obj.createdUserMessage = exports.UserMessage.toJSON(message.createdUserMessage);
        }
        if (message.userMessageUploaded !== undefined) {
            obj.userMessageUploaded = exports.UserMessageUploaded.toJSON(message.userMessageUploaded);
        }
        if (message.groupMessageUploaded !== undefined) {
            obj.groupMessageUploaded = exports.GroupMessage.toJSON(message.groupMessageUploaded);
        }
        return obj;
    },
    create(base) {
        return exports.Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse();
        message.id = object.id ?? 0;
        message.error = (object.error !== undefined && object.error !== null) ? exports.Error.fromPartial(object.error) : undefined;
        message.createdUserMessage = (object.createdUserMessage !== undefined && object.createdUserMessage !== null)
            ? exports.UserMessage.fromPartial(object.createdUserMessage)
            : undefined;
        message.userMessageUploaded = (object.userMessageUploaded !== undefined && object.userMessageUploaded !== null)
            ? exports.UserMessageUploaded.fromPartial(object.userMessageUploaded)
            : undefined;
        message.groupMessageUploaded = (object.groupMessageUploaded !== undefined && object.groupMessageUploaded !== null)
            ? exports.GroupMessage.fromPartial(object.groupMessageUploaded)
            : undefined;
        return message;
    },
};
function createBaseServerMessage() {
    return {
        userMessage: undefined,
        groupMessage: undefined,
        userMessages: undefined,
        groupMessages: undefined,
        response: undefined,
        ping: undefined,
        pong: undefined,
    };
}
exports.ServerMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userMessage !== undefined) {
            exports.UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
        }
        if (message.groupMessage !== undefined) {
            exports.GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
        }
        if (message.userMessages !== undefined) {
            exports.UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
        }
        if (message.groupMessages !== undefined) {
            exports.GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
        }
        if (message.response !== undefined) {
            exports.Response.encode(message.response, writer.uint32(82).fork()).join();
        }
        if (message.ping !== undefined) {
            writer.uint32(90).bytes(message.ping);
        }
        if (message.pong !== undefined) {
            writer.uint32(98).bytes(message.pong);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseServerMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.userMessage = exports.UserMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.groupMessage = exports.GroupMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.userMessages = exports.UserMessages.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.groupMessages = exports.GroupMessages.decode(reader, reader.uint32());
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.response = exports.Response.decode(reader, reader.uint32());
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.ping = reader.bytes();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.pong = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userMessage: isSet(object.userMessage) ? exports.UserMessage.fromJSON(object.userMessage) : undefined,
            groupMessage: isSet(object.groupMessage) ? exports.GroupMessage.fromJSON(object.groupMessage) : undefined,
            userMessages: isSet(object.userMessages) ? exports.UserMessages.fromJSON(object.userMessages) : undefined,
            groupMessages: isSet(object.groupMessages) ? exports.GroupMessages.fromJSON(object.groupMessages) : undefined,
            response: isSet(object.response) ? exports.Response.fromJSON(object.response) : undefined,
            ping: isSet(object.ping) ? bytesFromBase64(object.ping) : undefined,
            pong: isSet(object.pong) ? bytesFromBase64(object.pong) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userMessage !== undefined) {
            obj.userMessage = exports.UserMessage.toJSON(message.userMessage);
        }
        if (message.groupMessage !== undefined) {
            obj.groupMessage = exports.GroupMessage.toJSON(message.groupMessage);
        }
        if (message.userMessages !== undefined) {
            obj.userMessages = exports.UserMessages.toJSON(message.userMessages);
        }
        if (message.groupMessages !== undefined) {
            obj.groupMessages = exports.GroupMessages.toJSON(message.groupMessages);
        }
        if (message.response !== undefined) {
            obj.response = exports.Response.toJSON(message.response);
        }
        if (message.ping !== undefined) {
            obj.ping = base64FromBytes(message.ping);
        }
        if (message.pong !== undefined) {
            obj.pong = base64FromBytes(message.pong);
        }
        return obj;
    },
    create(base) {
        return exports.ServerMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseServerMessage();
        message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
            ? exports.UserMessage.fromPartial(object.userMessage)
            : undefined;
        message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
            ? exports.GroupMessage.fromPartial(object.groupMessage)
            : undefined;
        message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
            ? exports.UserMessages.fromPartial(object.userMessages)
            : undefined;
        message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
            ? exports.GroupMessages.fromPartial(object.groupMessages)
            : undefined;
        message.response = (object.response !== undefined && object.response !== null)
            ? exports.Response.fromPartial(object.response)
            : undefined;
        message.ping = object.ping ?? undefined;
        message.pong = object.pong ?? undefined;
        return message;
    },
};
function createBaseSubscribeGroup() {
    return { id: 0n };
}
exports.SubscribeGroup = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(8).uint64(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSubscribeGroup();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? BigInt(object.id) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        return obj;
    },
    create(base) {
        return exports.SubscribeGroup.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSubscribeGroup();
        message.id = object.id ?? 0n;
        return message;
    },
};
function createBaseUnSubscribeGroup() {
    return { id: 0n };
}
exports.UnSubscribeGroup = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(16).uint64(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnSubscribeGroup();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? BigInt(object.id) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        return obj;
    },
    create(base) {
        return exports.UnSubscribeGroup.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnSubscribeGroup();
        message.id = object.id ?? 0n;
        return message;
    },
};
function createBaseClientMessage() {
    return {
        userMessage: undefined,
        groupMessage: undefined,
        userMessages: undefined,
        groupMessages: undefined,
        bearerToken: undefined,
        subscribeGroup: undefined,
        unSubscribeGroup: undefined,
        request: undefined,
        ping: undefined,
        pong: undefined,
    };
}
exports.ClientMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userMessage !== undefined) {
            exports.UserMessage.encode(message.userMessage, writer.uint32(10).fork()).join();
        }
        if (message.groupMessage !== undefined) {
            exports.GroupMessage.encode(message.groupMessage, writer.uint32(18).fork()).join();
        }
        if (message.userMessages !== undefined) {
            exports.UserMessages.encode(message.userMessages, writer.uint32(26).fork()).join();
        }
        if (message.groupMessages !== undefined) {
            exports.GroupMessages.encode(message.groupMessages, writer.uint32(34).fork()).join();
        }
        if (message.bearerToken !== undefined) {
            writer.uint32(42).string(message.bearerToken);
        }
        if (message.subscribeGroup !== undefined) {
            exports.SubscribeGroup.encode(message.subscribeGroup, writer.uint32(50).fork()).join();
        }
        if (message.unSubscribeGroup !== undefined) {
            exports.UnSubscribeGroup.encode(message.unSubscribeGroup, writer.uint32(58).fork()).join();
        }
        if (message.request !== undefined) {
            exports.Request.encode(message.request, writer.uint32(82).fork()).join();
        }
        if (message.ping !== undefined) {
            writer.uint32(90).bytes(message.ping);
        }
        if (message.pong !== undefined) {
            writer.uint32(98).bytes(message.pong);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClientMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.userMessage = exports.UserMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.groupMessage = exports.GroupMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.userMessages = exports.UserMessages.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.groupMessages = exports.GroupMessages.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.bearerToken = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.subscribeGroup = exports.SubscribeGroup.decode(reader, reader.uint32());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.unSubscribeGroup = exports.UnSubscribeGroup.decode(reader, reader.uint32());
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.request = exports.Request.decode(reader, reader.uint32());
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.ping = reader.bytes();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.pong = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            userMessage: isSet(object.userMessage) ? exports.UserMessage.fromJSON(object.userMessage) : undefined,
            groupMessage: isSet(object.groupMessage) ? exports.GroupMessage.fromJSON(object.groupMessage) : undefined,
            userMessages: isSet(object.userMessages) ? exports.UserMessages.fromJSON(object.userMessages) : undefined,
            groupMessages: isSet(object.groupMessages) ? exports.GroupMessages.fromJSON(object.groupMessages) : undefined,
            bearerToken: isSet(object.bearerToken) ? globalThis.String(object.bearerToken) : undefined,
            subscribeGroup: isSet(object.subscribeGroup) ? exports.SubscribeGroup.fromJSON(object.subscribeGroup) : undefined,
            unSubscribeGroup: isSet(object.unSubscribeGroup) ? exports.UnSubscribeGroup.fromJSON(object.unSubscribeGroup) : undefined,
            request: isSet(object.request) ? exports.Request.fromJSON(object.request) : undefined,
            ping: isSet(object.ping) ? bytesFromBase64(object.ping) : undefined,
            pong: isSet(object.pong) ? bytesFromBase64(object.pong) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.userMessage !== undefined) {
            obj.userMessage = exports.UserMessage.toJSON(message.userMessage);
        }
        if (message.groupMessage !== undefined) {
            obj.groupMessage = exports.GroupMessage.toJSON(message.groupMessage);
        }
        if (message.userMessages !== undefined) {
            obj.userMessages = exports.UserMessages.toJSON(message.userMessages);
        }
        if (message.groupMessages !== undefined) {
            obj.groupMessages = exports.GroupMessages.toJSON(message.groupMessages);
        }
        if (message.bearerToken !== undefined) {
            obj.bearerToken = message.bearerToken;
        }
        if (message.subscribeGroup !== undefined) {
            obj.subscribeGroup = exports.SubscribeGroup.toJSON(message.subscribeGroup);
        }
        if (message.unSubscribeGroup !== undefined) {
            obj.unSubscribeGroup = exports.UnSubscribeGroup.toJSON(message.unSubscribeGroup);
        }
        if (message.request !== undefined) {
            obj.request = exports.Request.toJSON(message.request);
        }
        if (message.ping !== undefined) {
            obj.ping = base64FromBytes(message.ping);
        }
        if (message.pong !== undefined) {
            obj.pong = base64FromBytes(message.pong);
        }
        return obj;
    },
    create(base) {
        return exports.ClientMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseClientMessage();
        message.userMessage = (object.userMessage !== undefined && object.userMessage !== null)
            ? exports.UserMessage.fromPartial(object.userMessage)
            : undefined;
        message.groupMessage = (object.groupMessage !== undefined && object.groupMessage !== null)
            ? exports.GroupMessage.fromPartial(object.groupMessage)
            : undefined;
        message.userMessages = (object.userMessages !== undefined && object.userMessages !== null)
            ? exports.UserMessages.fromPartial(object.userMessages)
            : undefined;
        message.groupMessages = (object.groupMessages !== undefined && object.groupMessages !== null)
            ? exports.GroupMessages.fromPartial(object.groupMessages)
            : undefined;
        message.bearerToken = object.bearerToken ?? undefined;
        message.subscribeGroup = (object.subscribeGroup !== undefined && object.subscribeGroup !== null)
            ? exports.SubscribeGroup.fromPartial(object.subscribeGroup)
            : undefined;
        message.unSubscribeGroup = (object.unSubscribeGroup !== undefined && object.unSubscribeGroup !== null)
            ? exports.UnSubscribeGroup.fromPartial(object.unSubscribeGroup)
            : undefined;
        message.request = (object.request !== undefined && object.request !== null)
            ? exports.Request.fromPartial(object.request)
            : undefined;
        message.ping = object.ping ?? undefined;
        message.pong = object.pong ?? undefined;
        return message;
    },
};
function createBaseGroupId() {
    return { id: 0n };
}
exports.GroupId = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0n) {
            if (BigInt.asUintN(64, message.id) !== message.id) {
                throw new globalThis.Error("value provided for field message.id of type uint64 too large");
            }
            writer.uint32(16).uint64(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupId();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.id = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? BigInt(object.id) : 0n };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0n) {
            obj.id = message.id.toString();
        }
        return obj;
    },
    create(base) {
        return exports.GroupId.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupId();
        message.id = object.id ?? 0n;
        return message;
    },
};
function createBaseAuthToken() {
    return { username: "", validUntil: 0n, issuer: "", credential: new Uint8Array(0), deviceId: 0, addressId: 0n };
}
exports.AuthToken = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.username !== "") {
            writer.uint32(10).string(message.username);
        }
        if (message.validUntil !== 0n) {
            if (BigInt.asUintN(64, message.validUntil) !== message.validUntil) {
                throw new globalThis.Error("value provided for field message.validUntil of type uint64 too large");
            }
            writer.uint32(16).uint64(message.validUntil);
        }
        if (message.issuer !== "") {
            writer.uint32(26).string(message.issuer);
        }
        if (message.credential.length !== 0) {
            writer.uint32(34).bytes(message.credential);
        }
        if (message.deviceId !== 0) {
            writer.uint32(40).uint32(message.deviceId);
        }
        if (message.addressId !== 0n) {
            if (BigInt.asUintN(64, message.addressId) !== message.addressId) {
                throw new globalThis.Error("value provided for field message.addressId of type uint64 too large");
            }
            writer.uint32(48).uint64(message.addressId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAuthToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.validUntil = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.issuer = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.credential = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.deviceId = reader.uint32();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.addressId = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            username: isSet(object.username) ? globalThis.String(object.username) : "",
            validUntil: isSet(object.validUntil) ? BigInt(object.validUntil) : 0n,
            issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
            credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
            deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
            addressId: isSet(object.addressId) ? BigInt(object.addressId) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.username !== "") {
            obj.username = message.username;
        }
        if (message.validUntil !== 0n) {
            obj.validUntil = message.validUntil.toString();
        }
        if (message.issuer !== "") {
            obj.issuer = message.issuer;
        }
        if (message.credential.length !== 0) {
            obj.credential = base64FromBytes(message.credential);
        }
        if (message.deviceId !== 0) {
            obj.deviceId = Math.round(message.deviceId);
        }
        if (message.addressId !== 0n) {
            obj.addressId = message.addressId.toString();
        }
        return obj;
    },
    create(base) {
        return exports.AuthToken.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAuthToken();
        message.username = object.username ?? "";
        message.validUntil = object.validUntil ?? 0n;
        message.issuer = object.issuer ?? "";
        message.credential = object.credential ?? new Uint8Array(0);
        message.deviceId = object.deviceId ?? 0;
        message.addressId = object.addressId ?? 0n;
        return message;
    },
};
function createBaseSignedToken() {
    return { kid: "", payload: new Uint8Array(0), signature: new Uint8Array(0) };
}
exports.SignedToken = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.kid !== "") {
            writer.uint32(10).string(message.kid);
        }
        if (message.payload.length !== 0) {
            writer.uint32(18).bytes(message.payload);
        }
        if (message.signature.length !== 0) {
            writer.uint32(26).bytes(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedToken();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.kid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.payload = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            kid: isSet(object.kid) ? globalThis.String(object.kid) : "",
            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
            signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.kid !== "") {
            obj.kid = message.kid;
        }
        if (message.payload.length !== 0) {
            obj.payload = base64FromBytes(message.payload);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes(message.signature);
        }
        return obj;
    },
    create(base) {
        return exports.SignedToken.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignedToken();
        message.kid = object.kid ?? "";
        message.payload = object.payload ?? new Uint8Array(0);
        message.signature = object.signature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseFireflyIdentity() {
    return { secret: new Uint8Array(0), public: new Uint8Array(0), credential: new Uint8Array(0) };
}
exports.FireflyIdentity = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.secret.length !== 0) {
            writer.uint32(18).bytes(message.secret);
        }
        if (message.public.length !== 0) {
            writer.uint32(26).bytes(message.public);
        }
        if (message.credential.length !== 0) {
            writer.uint32(34).bytes(message.credential);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyIdentity();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.secret = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.public = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.credential = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            secret: isSet(object.secret) ? bytesFromBase64(object.secret) : new Uint8Array(0),
            public: isSet(object.public) ? bytesFromBase64(object.public) : new Uint8Array(0),
            credential: isSet(object.credential) ? bytesFromBase64(object.credential) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.secret.length !== 0) {
            obj.secret = base64FromBytes(message.secret);
        }
        if (message.public.length !== 0) {
            obj.public = base64FromBytes(message.public);
        }
        if (message.credential.length !== 0) {
            obj.credential = base64FromBytes(message.credential);
        }
        return obj;
    },
    create(base) {
        return exports.FireflyIdentity.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyIdentity();
        message.secret = object.secret ?? new Uint8Array(0);
        message.public = object.public ?? new Uint8Array(0);
        message.credential = object.credential ?? new Uint8Array(0);
        return message;
    },
};
function createBaseFireflyGroupExtension() {
    return { name: "", roles: undefined, channels: undefined, members: undefined };
}
exports.FireflyGroupExtension = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.roles !== undefined) {
            exports.FireflyGroupRoles.encode(message.roles, writer.uint32(18).fork()).join();
        }
        if (message.channels !== undefined) {
            exports.FireflyGroupChannels.encode(message.channels, writer.uint32(26).fork()).join();
        }
        if (message.members !== undefined) {
            exports.FireflyGroupMembers.encode(message.members, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupExtension();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.roles = exports.FireflyGroupRoles.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.channels = exports.FireflyGroupChannels.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.members = exports.FireflyGroupMembers.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            roles: isSet(object.roles) ? exports.FireflyGroupRoles.fromJSON(object.roles) : undefined,
            channels: isSet(object.channels) ? exports.FireflyGroupChannels.fromJSON(object.channels) : undefined,
            members: isSet(object.members) ? exports.FireflyGroupMembers.fromJSON(object.members) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.roles !== undefined) {
            obj.roles = exports.FireflyGroupRoles.toJSON(message.roles);
        }
        if (message.channels !== undefined) {
            obj.channels = exports.FireflyGroupChannels.toJSON(message.channels);
        }
        if (message.members !== undefined) {
            obj.members = exports.FireflyGroupMembers.toJSON(message.members);
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupExtension.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupExtension();
        message.name = object.name ?? "";
        message.roles = (object.roles !== undefined && object.roles !== null)
            ? exports.FireflyGroupRoles.fromPartial(object.roles)
            : undefined;
        message.channels = (object.channels !== undefined && object.channels !== null)
            ? exports.FireflyGroupChannels.fromPartial(object.channels)
            : undefined;
        message.members = (object.members !== undefined && object.members !== null)
            ? exports.FireflyGroupMembers.fromPartial(object.members)
            : undefined;
        return message;
    },
};
function createBaseFireflyGroupRole() {
    return { id: 0, name: "", permissions: 0 };
}
exports.FireflyGroupRole = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.permissions !== 0) {
            writer.uint32(24).uint32(message.permissions);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupRole();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.permissions = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.permissions !== 0) {
            obj.permissions = Math.round(message.permissions);
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupRole.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupRole();
        message.id = object.id ?? 0;
        message.name = object.name ?? "";
        message.permissions = object.permissions ?? 0;
        return message;
    },
};
function createBaseFireflyGroupRoles() {
    return { roles: [] };
}
exports.FireflyGroupRoles = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.roles) {
            exports.FireflyGroupRole.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupRoles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.roles.push(exports.FireflyGroupRole.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e) => exports.FireflyGroupRole.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.roles?.length) {
            obj.roles = message.roles.map((e) => exports.FireflyGroupRole.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupRoles.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupRoles();
        message.roles = object.roles?.map((e) => exports.FireflyGroupRole.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFireflyGroupMember() {
    return { username: "", role: 0 };
}
exports.FireflyGroupMember = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.username !== "") {
            writer.uint32(10).string(message.username);
        }
        if (message.role !== 0) {
            writer.uint32(16).uint32(message.role);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupMember();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.role = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            username: isSet(object.username) ? globalThis.String(object.username) : "",
            role: isSet(object.role) ? globalThis.Number(object.role) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.username !== "") {
            obj.username = message.username;
        }
        if (message.role !== 0) {
            obj.role = Math.round(message.role);
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupMember.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupMember();
        message.username = object.username ?? "";
        message.role = object.role ?? 0;
        return message;
    },
};
function createBaseFireflyGroupMembers() {
    return { members: [] };
}
exports.FireflyGroupMembers = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.members) {
            exports.FireflyGroupMember.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupMembers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.members.push(exports.FireflyGroupMember.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            members: globalThis.Array.isArray(object?.members)
                ? object.members.map((e) => exports.FireflyGroupMember.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.members?.length) {
            obj.members = message.members.map((e) => exports.FireflyGroupMember.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupMembers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupMembers();
        message.members = object.members?.map((e) => exports.FireflyGroupMember.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFireflyGroupChannel() {
    return { id: 0, name: "", type: 0, roles: undefined };
}
exports.FireflyGroupChannel = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.type !== 0) {
            writer.uint32(24).uint32(message.type);
        }
        if (message.roles !== undefined) {
            exports.FireflyGroupRoles.encode(message.roles, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupChannel();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.type = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.roles = exports.FireflyGroupRoles.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            type: isSet(object.type) ? globalThis.Number(object.type) : 0,
            roles: isSet(object.roles) ? exports.FireflyGroupRoles.fromJSON(object.roles) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.type !== 0) {
            obj.type = Math.round(message.type);
        }
        if (message.roles !== undefined) {
            obj.roles = exports.FireflyGroupRoles.toJSON(message.roles);
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupChannel.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupChannel();
        message.id = object.id ?? 0;
        message.name = object.name ?? "";
        message.type = object.type ?? 0;
        message.roles = (object.roles !== undefined && object.roles !== null)
            ? exports.FireflyGroupRoles.fromPartial(object.roles)
            : undefined;
        return message;
    },
};
function createBaseFireflyGroupChannels() {
    return { channels: [] };
}
exports.FireflyGroupChannels = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.channels) {
            exports.FireflyGroupChannel.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFireflyGroupChannels();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.channels.push(exports.FireflyGroupChannel.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            channels: globalThis.Array.isArray(object?.channels)
                ? object.channels.map((e) => exports.FireflyGroupChannel.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.channels?.length) {
            obj.channels = message.channels.map((e) => exports.FireflyGroupChannel.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.FireflyGroupChannels.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFireflyGroupChannels();
        message.channels = object.channels?.map((e) => exports.FireflyGroupChannel.fromPartial(e)) || [];
        return message;
    },
};
function createBasePreKeyBundle() {
    return {
        registrationId: 0,
        deviceId: 0,
        preKeyId: 0,
        prePublicKey: new Uint8Array(0),
        signedPreKeyId: 0,
        signedPrePublicKey: new Uint8Array(0),
        signedPreKeySignature: new Uint8Array(0),
        identityPublicKey: new Uint8Array(0),
        KEMPreKeyId: 0,
        KEMPrePublicKey: new Uint8Array(0),
        KEMPreKeySignature: new Uint8Array(0),
    };
}
exports.PreKeyBundle = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.registrationId !== 0) {
            writer.uint32(8).uint32(message.registrationId);
        }
        if (message.deviceId !== 0) {
            writer.uint32(16).uint32(message.deviceId);
        }
        if (message.preKeyId !== 0) {
            writer.uint32(24).uint32(message.preKeyId);
        }
        if (message.prePublicKey.length !== 0) {
            writer.uint32(34).bytes(message.prePublicKey);
        }
        if (message.signedPreKeyId !== 0) {
            writer.uint32(40).uint32(message.signedPreKeyId);
        }
        if (message.signedPrePublicKey.length !== 0) {
            writer.uint32(50).bytes(message.signedPrePublicKey);
        }
        if (message.signedPreKeySignature.length !== 0) {
            writer.uint32(58).bytes(message.signedPreKeySignature);
        }
        if (message.identityPublicKey.length !== 0) {
            writer.uint32(66).bytes(message.identityPublicKey);
        }
        if (message.KEMPreKeyId !== 0) {
            writer.uint32(72).uint32(message.KEMPreKeyId);
        }
        if (message.KEMPrePublicKey.length !== 0) {
            writer.uint32(82).bytes(message.KEMPrePublicKey);
        }
        if (message.KEMPreKeySignature.length !== 0) {
            writer.uint32(90).bytes(message.KEMPreKeySignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreKeyBundle();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.registrationId = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.deviceId = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.preKeyId = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.prePublicKey = reader.bytes();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.signedPreKeyId = reader.uint32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.signedPrePublicKey = reader.bytes();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.signedPreKeySignature = reader.bytes();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.identityPublicKey = reader.bytes();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.KEMPreKeyId = reader.uint32();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.KEMPrePublicKey = reader.bytes();
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.KEMPreKeySignature = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            registrationId: isSet(object.registrationId) ? globalThis.Number(object.registrationId) : 0,
            deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
            preKeyId: isSet(object.preKeyId) ? globalThis.Number(object.preKeyId) : 0,
            prePublicKey: isSet(object.prePublicKey) ? bytesFromBase64(object.prePublicKey) : new Uint8Array(0),
            signedPreKeyId: isSet(object.signedPreKeyId) ? globalThis.Number(object.signedPreKeyId) : 0,
            signedPrePublicKey: isSet(object.signedPrePublicKey)
                ? bytesFromBase64(object.signedPrePublicKey)
                : new Uint8Array(0),
            signedPreKeySignature: isSet(object.signedPreKeySignature)
                ? bytesFromBase64(object.signedPreKeySignature)
                : new Uint8Array(0),
            identityPublicKey: isSet(object.identityPublicKey)
                ? bytesFromBase64(object.identityPublicKey)
                : new Uint8Array(0),
            KEMPreKeyId: isSet(object.KEMPreKeyId) ? globalThis.Number(object.KEMPreKeyId) : 0,
            KEMPrePublicKey: isSet(object.KEMPrePublicKey) ? bytesFromBase64(object.KEMPrePublicKey) : new Uint8Array(0),
            KEMPreKeySignature: isSet(object.KEMPreKeySignature)
                ? bytesFromBase64(object.KEMPreKeySignature)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.registrationId !== 0) {
            obj.registrationId = Math.round(message.registrationId);
        }
        if (message.deviceId !== 0) {
            obj.deviceId = Math.round(message.deviceId);
        }
        if (message.preKeyId !== 0) {
            obj.preKeyId = Math.round(message.preKeyId);
        }
        if (message.prePublicKey.length !== 0) {
            obj.prePublicKey = base64FromBytes(message.prePublicKey);
        }
        if (message.signedPreKeyId !== 0) {
            obj.signedPreKeyId = Math.round(message.signedPreKeyId);
        }
        if (message.signedPrePublicKey.length !== 0) {
            obj.signedPrePublicKey = base64FromBytes(message.signedPrePublicKey);
        }
        if (message.signedPreKeySignature.length !== 0) {
            obj.signedPreKeySignature = base64FromBytes(message.signedPreKeySignature);
        }
        if (message.identityPublicKey.length !== 0) {
            obj.identityPublicKey = base64FromBytes(message.identityPublicKey);
        }
        if (message.KEMPreKeyId !== 0) {
            obj.KEMPreKeyId = Math.round(message.KEMPreKeyId);
        }
        if (message.KEMPrePublicKey.length !== 0) {
            obj.KEMPrePublicKey = base64FromBytes(message.KEMPrePublicKey);
        }
        if (message.KEMPreKeySignature.length !== 0) {
            obj.KEMPreKeySignature = base64FromBytes(message.KEMPreKeySignature);
        }
        return obj;
    },
    create(base) {
        return exports.PreKeyBundle.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreKeyBundle();
        message.registrationId = object.registrationId ?? 0;
        message.deviceId = object.deviceId ?? 0;
        message.preKeyId = object.preKeyId ?? 0;
        message.prePublicKey = object.prePublicKey ?? new Uint8Array(0);
        message.signedPreKeyId = object.signedPreKeyId ?? 0;
        message.signedPrePublicKey = object.signedPrePublicKey ?? new Uint8Array(0);
        message.signedPreKeySignature = object.signedPreKeySignature ?? new Uint8Array(0);
        message.identityPublicKey = object.identityPublicKey ?? new Uint8Array(0);
        message.KEMPreKeyId = object.KEMPreKeyId ?? 0;
        message.KEMPrePublicKey = object.KEMPrePublicKey ?? new Uint8Array(0);
        message.KEMPreKeySignature = object.KEMPreKeySignature ?? new Uint8Array(0);
        return message;
    },
};
function createBasePreKeyBundleEntry() {
    return { id: 0, address: 0n, bundle: undefined, username: "", deviceId: 0 };
}
exports.PreKeyBundleEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.address !== 0n) {
            if (BigInt.asUintN(64, message.address) !== message.address) {
                throw new globalThis.Error("value provided for field message.address of type uint64 too large");
            }
            writer.uint32(16).uint64(message.address);
        }
        if (message.bundle !== undefined) {
            exports.PreKeyBundle.encode(message.bundle, writer.uint32(26).fork()).join();
        }
        if (message.username !== "") {
            writer.uint32(34).string(message.username);
        }
        if (message.deviceId !== 0) {
            writer.uint32(40).uint32(message.deviceId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreKeyBundleEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.address = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.bundle = exports.PreKeyBundle.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.username = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.deviceId = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            address: isSet(object.address) ? BigInt(object.address) : 0n,
            bundle: isSet(object.bundle) ? exports.PreKeyBundle.fromJSON(object.bundle) : undefined,
            username: isSet(object.username) ? globalThis.String(object.username) : "",
            deviceId: isSet(object.deviceId) ? globalThis.Number(object.deviceId) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.address !== 0n) {
            obj.address = message.address.toString();
        }
        if (message.bundle !== undefined) {
            obj.bundle = exports.PreKeyBundle.toJSON(message.bundle);
        }
        if (message.username !== "") {
            obj.username = message.username;
        }
        if (message.deviceId !== 0) {
            obj.deviceId = Math.round(message.deviceId);
        }
        return obj;
    },
    create(base) {
        return exports.PreKeyBundleEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreKeyBundleEntry();
        message.id = object.id ?? 0;
        message.address = object.address ?? 0n;
        message.bundle = (object.bundle !== undefined && object.bundle !== null)
            ? exports.PreKeyBundle.fromPartial(object.bundle)
            : undefined;
        message.username = object.username ?? "";
        message.deviceId = object.deviceId ?? 0;
        return message;
    },
};
function createBasePreKeyBundleEntries() {
    return { entries: [] };
}
exports.PreKeyBundleEntries = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.entries) {
            exports.PreKeyBundleEntry.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreKeyBundleEntries();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.entries.push(exports.PreKeyBundleEntry.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            entries: globalThis.Array.isArray(object?.entries)
                ? object.entries.map((e) => exports.PreKeyBundleEntry.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.entries?.length) {
            obj.entries = message.entries.map((e) => exports.PreKeyBundleEntry.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PreKeyBundleEntries.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreKeyBundleEntries();
        message.entries = object.entries?.map((e) => exports.PreKeyBundleEntry.fromPartial(e)) || [];
        return message;
    },
};
function createBaseConversationStart() {
    return { conversationId: 0n, startedBy: "", other: "", bundle: undefined };
}
exports.ConversationStart = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.conversationId !== 0n) {
            if (BigInt.asUintN(64, message.conversationId) !== message.conversationId) {
                throw new globalThis.Error("value provided for field message.conversationId of type uint64 too large");
            }
            writer.uint32(8).uint64(message.conversationId);
        }
        if (message.startedBy !== "") {
            writer.uint32(18).string(message.startedBy);
        }
        if (message.other !== "") {
            writer.uint32(26).string(message.other);
        }
        if (message.bundle !== undefined) {
            exports.PreKeyBundle.encode(message.bundle, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversationStart();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.conversationId = reader.uint64();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.startedBy = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.other = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.bundle = exports.PreKeyBundle.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversationId: isSet(object.conversationId) ? BigInt(object.conversationId) : 0n,
            startedBy: isSet(object.startedBy) ? globalThis.String(object.startedBy) : "",
            other: isSet(object.other) ? globalThis.String(object.other) : "",
            bundle: isSet(object.bundle) ? exports.PreKeyBundle.fromJSON(object.bundle) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversationId !== 0n) {
            obj.conversationId = message.conversationId.toString();
        }
        if (message.startedBy !== "") {
            obj.startedBy = message.startedBy;
        }
        if (message.other !== "") {
            obj.other = message.other;
        }
        if (message.bundle !== undefined) {
            obj.bundle = exports.PreKeyBundle.toJSON(message.bundle);
        }
        return obj;
    },
    create(base) {
        return exports.ConversationStart.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversationStart();
        message.conversationId = object.conversationId ?? 0n;
        message.startedBy = object.startedBy ?? "";
        message.other = object.other ?? "";
        message.bundle = (object.bundle !== undefined && object.bundle !== null)
            ? exports.PreKeyBundle.fromPartial(object.bundle)
            : undefined;
        return message;
    },
};
function createBasePreKeyBundles() {
    return { bundles: [] };
}
exports.PreKeyBundles = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.bundles) {
            exports.PreKeyBundle.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreKeyBundles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.bundles.push(exports.PreKeyBundle.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bundles: globalThis.Array.isArray(object?.bundles)
                ? object.bundles.map((e) => exports.PreKeyBundle.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bundles?.length) {
            obj.bundles = message.bundles.map((e) => exports.PreKeyBundle.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.PreKeyBundles.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreKeyBundles();
        message.bundles = object.bundles?.map((e) => exports.PreKeyBundle.fromPartial(e)) || [];
        return message;
    },
};
function createBaseConversation() {
    return { user1: "", user2: "", settings: 0n };
}
exports.Conversation = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user1 !== "") {
            writer.uint32(10).string(message.user1);
        }
        if (message.user2 !== "") {
            writer.uint32(18).string(message.user2);
        }
        if (message.settings !== 0n) {
            if (BigInt.asUintN(64, message.settings) !== message.settings) {
                throw new globalThis.Error("value provided for field message.settings of type uint64 too large");
            }
            writer.uint32(24).uint64(message.settings);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.user1 = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.user2 = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.settings = reader.uint64();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            user1: isSet(object.user1) ? globalThis.String(object.user1) : "",
            user2: isSet(object.user2) ? globalThis.String(object.user2) : "",
            settings: isSet(object.settings) ? BigInt(object.settings) : 0n,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.user1 !== "") {
            obj.user1 = message.user1;
        }
        if (message.user2 !== "") {
            obj.user2 = message.user2;
        }
        if (message.settings !== 0n) {
            obj.settings = message.settings.toString();
        }
        return obj;
    },
    create(base) {
        return exports.Conversation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversation();
        message.user1 = object.user1 ?? "";
        message.user2 = object.user2 ?? "";
        message.settings = object.settings ?? 0n;
        return message;
    },
};
function createBaseConversations() {
    return { conversations: [] };
}
exports.Conversations = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.conversations) {
            exports.Conversation.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConversations();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.conversations.push(exports.Conversation.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            conversations: globalThis.Array.isArray(object?.conversations)
                ? object.conversations.map((e) => exports.Conversation.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.conversations?.length) {
            obj.conversations = message.conversations.map((e) => exports.Conversation.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.Conversations.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConversations();
        message.conversations = object.conversations?.map((e) => exports.Conversation.fromPartial(e)) || [];
        return message;
    },
};
function createBaseEncryptedFile() {
    return { url: "", contentType: 0, secretKey: new Uint8Array(0), contentLength: 0 };
}
exports.EncryptedFile = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.url !== "") {
            writer.uint32(10).string(message.url);
        }
        if (message.contentType !== 0) {
            writer.uint32(16).uint32(message.contentType);
        }
        if (message.secretKey.length !== 0) {
            writer.uint32(26).bytes(message.secretKey);
        }
        if (message.contentLength !== 0) {
            writer.uint32(32).uint32(message.contentLength);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptedFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.contentType = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.secretKey = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.contentLength = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            url: isSet(object.url) ? globalThis.String(object.url) : "",
            contentType: isSet(object.contentType) ? globalThis.Number(object.contentType) : 0,
            secretKey: isSet(object.secretKey) ? bytesFromBase64(object.secretKey) : new Uint8Array(0),
            contentLength: isSet(object.contentLength) ? globalThis.Number(object.contentLength) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.url !== "") {
            obj.url = message.url;
        }
        if (message.contentType !== 0) {
            obj.contentType = Math.round(message.contentType);
        }
        if (message.secretKey.length !== 0) {
            obj.secretKey = base64FromBytes(message.secretKey);
        }
        if (message.contentLength !== 0) {
            obj.contentLength = Math.round(message.contentLength);
        }
        return obj;
    },
    create(base) {
        return exports.EncryptedFile.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEncryptedFile();
        message.url = object.url ?? "";
        message.contentType = object.contentType ?? 0;
        message.secretKey = object.secretKey ?? new Uint8Array(0);
        message.contentLength = object.contentLength ?? 0;
        return message;
    },
};
function createBaseEncryptedFiles() {
    return { files: [] };
}
exports.EncryptedFiles = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.files) {
            exports.EncryptedFile.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEncryptedFiles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.files.push(exports.EncryptedFile.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            files: globalThis.Array.isArray(object?.files) ? object.files.map((e) => exports.EncryptedFile.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.files?.length) {
            obj.files = message.files.map((e) => exports.EncryptedFile.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.EncryptedFiles.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEncryptedFiles();
        message.files = object.files?.map((e) => exports.EncryptedFile.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMessagePayload() {
    return { text: "", replyingTo: 0n, files: undefined };
}
exports.MessagePayload = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        if (message.replyingTo !== 0n) {
            if (BigInt.asUintN(64, message.replyingTo) !== message.replyingTo) {
                throw new globalThis.Error("value provided for field message.replyingTo of type uint64 too large");
            }
            writer.uint32(16).uint64(message.replyingTo);
        }
        if (message.files !== undefined) {
            exports.EncryptedFiles.encode(message.files, writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessagePayload();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.replyingTo = reader.uint64();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.files = exports.EncryptedFiles.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? globalThis.String(object.text) : "",
            replyingTo: isSet(object.replyingTo) ? BigInt(object.replyingTo) : 0n,
            files: isSet(object.files) ? exports.EncryptedFiles.fromJSON(object.files) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        if (message.replyingTo !== 0n) {
            obj.replyingTo = message.replyingTo.toString();
        }
        if (message.files !== undefined) {
            obj.files = exports.EncryptedFiles.toJSON(message.files);
        }
        return obj;
    },
    create(base) {
        return exports.MessagePayload.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMessagePayload();
        message.text = object.text ?? "";
        message.replyingTo = object.replyingTo ?? 0n;
        message.files = (object.files !== undefined && object.files !== null)
            ? exports.EncryptedFiles.fromPartial(object.files)
            : undefined;
        return message;
    },
};
function createBaseCallMessage() {
    return { message: new Uint8Array(0), sessionId: 0, type: 0, jsonBody: "" };
}
exports.CallMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.message.length !== 0) {
            writer.uint32(10).bytes(message.message);
        }
        if (message.sessionId !== 0) {
            writer.uint32(16).uint32(message.sessionId);
        }
        if (message.type !== 0) {
            writer.uint32(24).int32(message.type);
        }
        if (message.jsonBody !== "") {
            writer.uint32(34).string(message.jsonBody);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCallMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.sessionId = reader.uint32();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.jsonBody = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
            sessionId: isSet(object.sessionId) ? globalThis.Number(object.sessionId) : 0,
            type: isSet(object.type) ? callMessageTypeFromJSON(object.type) : 0,
            jsonBody: isSet(object.jsonBody) ? globalThis.String(object.jsonBody) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.message.length !== 0) {
            obj.message = base64FromBytes(message.message);
        }
        if (message.sessionId !== 0) {
            obj.sessionId = Math.round(message.sessionId);
        }
        if (message.type !== 0) {
            obj.type = callMessageTypeToJSON(message.type);
        }
        if (message.jsonBody !== "") {
            obj.jsonBody = message.jsonBody;
        }
        return obj;
    },
    create(base) {
        return exports.CallMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCallMessage();
        message.message = object.message ?? new Uint8Array(0);
        message.sessionId = object.sessionId ?? 0;
        message.type = object.type ?? 0;
        message.jsonBody = object.jsonBody ?? "";
        return message;
    },
};
function createBaseSelfUserMessage() {
    return { to: "", inner: new Uint8Array(0) };
}
exports.SelfUserMessage = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.to !== "") {
            writer.uint32(10).string(message.to);
        }
        if (message.inner.length !== 0) {
            writer.uint32(18).bytes(message.inner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSelfUserMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.to = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.inner = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            to: isSet(object.to) ? globalThis.String(object.to) : "",
            inner: isSet(object.inner) ? bytesFromBase64(object.inner) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.to !== "") {
            obj.to = message.to;
        }
        if (message.inner.length !== 0) {
            obj.inner = base64FromBytes(message.inner);
        }
        return obj;
    },
    create(base) {
        return exports.SelfUserMessage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSelfUserMessage();
        message.to = object.to ?? "";
        message.inner = object.inner ?? new Uint8Array(0);
        return message;
    },
};
function createBaseUserMessageInner() {
    return { plainText: undefined, callMessage: undefined, messagePayload: undefined, selfMessage: undefined };
}
exports.UserMessageInner = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.plainText !== undefined) {
            writer.uint32(10).bytes(message.plainText);
        }
        if (message.callMessage !== undefined) {
            exports.CallMessage.encode(message.callMessage, writer.uint32(18).fork()).join();
        }
        if (message.messagePayload !== undefined) {
            exports.MessagePayload.encode(message.messagePayload, writer.uint32(26).fork()).join();
        }
        if (message.selfMessage !== undefined) {
            exports.SelfUserMessage.encode(message.selfMessage, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserMessageInner();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.plainText = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.callMessage = exports.CallMessage.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.messagePayload = exports.MessagePayload.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.selfMessage = exports.SelfUserMessage.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            plainText: isSet(object.plainText) ? bytesFromBase64(object.plainText) : undefined,
            callMessage: isSet(object.callMessage) ? exports.CallMessage.fromJSON(object.callMessage) : undefined,
            messagePayload: isSet(object.messagePayload) ? exports.MessagePayload.fromJSON(object.messagePayload) : undefined,
            selfMessage: isSet(object.selfMessage) ? exports.SelfUserMessage.fromJSON(object.selfMessage) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.plainText !== undefined) {
            obj.plainText = base64FromBytes(message.plainText);
        }
        if (message.callMessage !== undefined) {
            obj.callMessage = exports.CallMessage.toJSON(message.callMessage);
        }
        if (message.messagePayload !== undefined) {
            obj.messagePayload = exports.MessagePayload.toJSON(message.messagePayload);
        }
        if (message.selfMessage !== undefined) {
            obj.selfMessage = exports.SelfUserMessage.toJSON(message.selfMessage);
        }
        return obj;
    },
    create(base) {
        return exports.UserMessageInner.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserMessageInner();
        message.plainText = object.plainText ?? undefined;
        message.callMessage = (object.callMessage !== undefined && object.callMessage !== null)
            ? exports.CallMessage.fromPartial(object.callMessage)
            : undefined;
        message.messagePayload = (object.messagePayload !== undefined && object.messagePayload !== null)
            ? exports.MessagePayload.fromPartial(object.messagePayload)
            : undefined;
        message.selfMessage = (object.selfMessage !== undefined && object.selfMessage !== null)
            ? exports.SelfUserMessage.fromPartial(object.selfMessage)
            : undefined;
        return message;
    },
};
function createBaseGroupMessageInner() {
    return { channelId: 0, messagePayload: undefined };
}
exports.GroupMessageInner = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.channelId !== 0) {
            writer.uint32(8).uint32(message.channelId);
        }
        if (message.messagePayload !== undefined) {
            exports.MessagePayload.encode(message.messagePayload, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGroupMessageInner();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.channelId = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.messagePayload = exports.MessagePayload.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            channelId: isSet(object.channelId) ? globalThis.Number(object.channelId) : 0,
            messagePayload: isSet(object.messagePayload) ? exports.MessagePayload.fromJSON(object.messagePayload) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.channelId !== 0) {
            obj.channelId = Math.round(message.channelId);
        }
        if (message.messagePayload !== undefined) {
            obj.messagePayload = exports.MessagePayload.toJSON(message.messagePayload);
        }
        return obj;
    },
    create(base) {
        return exports.GroupMessageInner.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseGroupMessageInner();
        message.channelId = object.channelId ?? 0;
        message.messagePayload = (object.messagePayload !== undefined && object.messagePayload !== null)
            ? exports.MessagePayload.fromPartial(object.messagePayload)
            : undefined;
        return message;
    },
};
function bytesFromBase64(b64) {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
function base64FromBytes(arr) {
    const bin = [];
    arr.forEach((byte) => {
        bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
}
function isSet(value) {
    return value !== null && value !== undefined;
}
